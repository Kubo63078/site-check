<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>원세이버스 리액터 설치 통합 조사 시스템 v5.0 - Dynamic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1a1a2e;
            color: #333;
            height: 100vh;
            overflow: hidden;
        }

        .main-container {
            height: 100vh;
        }

        /* 메인 콘텐츠 영역 */
        .content-area {
            display: flex;
            flex-direction: column;
            background: #f0f0f0;
            overflow: hidden;
            height: 100vh;
        }

        /* 헤더 */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            padding: 5px 10px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }

        .header-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        /* 모바일 햄버거 메뉴 스타일 */
        .mobile-menu-container {
            display: none;
            position: relative;
        }

        .hamburger-btn {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 30px;
            height: 30px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
        }

        .hamburger-btn span {
            display: block;
            width: 20px;
            height: 2px;
            background: white;
            margin: 2px 0;
            transition: all 0.3s ease;
            border-radius: 1px;
        }

        .hamburger-btn.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .hamburger-btn.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger-btn.active span:nth-child(3) {
            transform: rotate(-45deg) translate(7px, -6px);
        }

        .mobile-menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            min-width: 200px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .mobile-menu-dropdown.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .mobile-menu-btn {
            display: block;
            width: 100%;
            padding: 12px 16px;
            background: transparent;
            border: none;
            text-align: left;
            color: #333;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            border-bottom: 1px solid #f0f0f0;
        }

        .mobile-menu-btn:last-child {
            border-bottom: none;
        }

        .mobile-menu-btn:hover {
            background: #f8f9ff;
        }

        .mobile-menu-btn:first-child {
            border-radius: 8px 8px 0 0;
        }

        .mobile-menu-btn:last-child {
            border-radius: 0 0 8px 8px;
        }

        /* 트리 뷰 컨테이너 */
        .tree-view-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: none;
        }

        .tree-view-container.active {
            display: block;
        }

        /* 트리 구조 스타일 */
        .tree-diagram {
            border-radius: 15px;
            padding: 30px;
            position: relative;
            overflow-x: auto;
            overflow-y: visible;
            transform-origin: top left;
            transition: transform 0.3s ease;
            display: inline-block;
            min-width: 100%;
        }

        /* 트리 다이어그램 배경 컨테이너 */
        .tree-view-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: none;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            margin: 20px;
        }

        .tree-node {
            position: relative;
            display: inline-block;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 10px 14px;
            margin: 6px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 140px;
        }

        .tree-node:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            background: #f8f9ff;
        }

        .tree-node.selected {
            background: #667eea;
            color: white;
            border-color: #764ba2;
        }

        .tree-node.selected .node-status,
        .tree-node.selected .node-actions {
            background: white;
            color: #667eea;
        }

        .tree-node.add-node {
            border: 2px dashed #999;
            background: #f9f9f9;
            opacity: 0.7;
        }

        .tree-node.add-node:hover {
            opacity: 1;
            border-color: #4CAF50;
            background: #e8f5e9;
        }

        .node-title {
            font-weight: 700;
            font-size: 13px;
            margin-bottom: 4px;
            color: #2c3e50;
            line-height: 1.3;
        }

        .node-info {
            font-size: 11px;
            color: #555;
            font-weight: 500;
            line-height: 1.4;
        }
        .node-info.missing {
            color: #f44336;
            font-weight: bold;
        }

        .node-status {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .node-status.incomplete {
            background: #ff9800;
        }

        .node-status.empty {
            background: #e0e0e0;
        }

        /* 사진 표시 영역 */
        .node-photos {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            max-width: 140px;
        }

        .node-photos img {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .node-photos img:hover {
            transform: scale(1.1);
        }

        /* 사진 버튼 스타일 */
        .photo-btn {
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 9px;
            font-size: 11px;
            cursor: pointer;
            margin: 3px 0;
            transition: all 0.2s;
        }

        .photo-btn:hover {
            background: #f57c00;
            transform: translateY(-1px);
        }

        /* 노드 액션 버튼 */
        .node-actions {
            position: absolute;
            top: -10px;
            left: -10px;
            display: none;
            gap: 5px;
        }

        .tree-node:hover .node-actions {
            display: flex;
        }

        .node-action-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s;
        }

        .node-action-btn.delete {
            background: #f44336;
            color: white;
        }

        .node-action-btn.edit {
            background: #2196F3;
            color: white;
        }

        .node-action-btn:hover {
            transform: scale(1.2);
        }

        /* 트리 계층 구조 */
        .tree-level {
            display: flex;
            justify-content: center;
            margin: 40px 0;
            position: relative;
            flex-wrap: nowrap;
            gap: 20px;
            min-width: max-content;
        }

        .tree-level-1 {
            justify-content: center;
        }

        .tree-level-2 {
            justify-content: center;
            padding: 0 50px;
        }

        .tree-level-3 {
            justify-content: center;
            padding: 0 30px;
        }

        .tree-level-4 {
            justify-content: center;
            padding: 0 20px;
        }

        /* 상세 정보 패널 */
        .detail-panel {
            position: fixed;
            right: -70vw;
            top: 0;
            width: 70vw;
            max-width: 70%;
            max-height: 70vh;
            height: 100vh;
            background: white;
            box-shadow: -5px 0 20px rgba(0,0,0,0.2);
            transition: right 0.3s;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transform: scale(1) !important;
        }

        .detail-panel.open {
            right: 0;
        }

        .detail-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .detail-header h2 {
            font-size: 18px;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .close-btn:hover {
            transform: rotate(90deg);
        }

        .detail-content {
            flex: 1;
            padding: 20px;
            padding-bottom: 0;
            overflow-y: auto;
        }

        .detail-footer {
            background: white;
            padding: 20px;
            padding-bottom: 50px;
            /* iOS safe area 대응 */
            padding-bottom: calc(50px + env(safe-area-inset-bottom));
            border-top: 1px solid #e0e0e0;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        }

        .detail-form-group {
            margin-bottom: 12px;
        }

        .detail-form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
            font-size: 13px;
        }

        .detail-form-control {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .detail-form-control:focus {
            outline: none;
            border-color: #667eea;
        }

        /* 통계 카드 */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        /* 프로그레스 바 */
        .progress-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .progress-bar {
            background: #e0e0e0;
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        /* 모달 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
            animation: fadeIn 0.3s;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 70vw;
            max-width: 70%;
            max-height: 70vh;
            overflow-y: auto;
            animation: slideUp 0.3s;
        }

        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #333;
        }

        .modal-body {
            margin-bottom: 8px;
        }

        .modal-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        /* 버튼 스타일 */
        .btn {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-warning {
            background: #ff9800;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }


        /* SVG 연결선 스타일 */
        .tree-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .tree-path {
            fill: none;
            stroke: #667eea;
            stroke-width: 2;
            opacity: 0.5;
        }

        .tree-path.highlighted {
            stroke: #e94560;
            stroke-width: 3;
            opacity: 1;
        }

        /* 툴팁 */
        .tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip.show {
            opacity: 1;
        }

        /* 애니메이션 */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* 모바일 최적화 */
        @media (max-width: 768px) {

            .content-area {
                order: 1;
                height: calc(100vh - 60px);
            }

            .header {
                padding: 15px 20px;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }

            .header h1 {
                font-size: 18px;
            }

            /* 기존 버튼들 숨김 */
            .header-actions {
                display: none;
            }

            /* 햄버거 메뉴 표시 */
            .mobile-menu-container {
                display: block;
            }

            .tree-view-container {
                padding: 15px;
            }

            .stats-container {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .stat-card {
                padding: 15px;
            }

            .tree-node {
                padding: 12px 15px;
                margin: 8px;
                min-width: 120px;
            }

            .node-title {
                font-size: 14px;
            }

            .node-info {
                font-size: 12px;
            }

            .node-photos img {
                width: 30px;
                height: 30px;
            }

            .detail-panel {
                right: -100%;
                width: 100%;
                top: 0;
            }

            .detail-panel.open {
                right: 0;
            }

            .modal-content {
                width: 95%;
                max-height: 85vh;
                margin: 20px auto;
            }

            .photo-btn {
                padding: 6px 10px;
                font-size: 13px;
                width: 100%;
                margin: 4px 0;
            }

            /* 터치 친화적 버튼 크기 */
            .btn {
                min-height: 40px;
                touch-action: manipulation;
            }

            .header-btn {
                min-height: 36px;
                touch-action: manipulation;
            }

            .tree-node {
                touch-action: manipulation;
                min-height: 60px;
            }

            /* 확대된 텍스트 입력 */
            .detail-form-control {
                font-size: 16px; /* iOS 줌 방지 */
                padding: 12px;
                min-height: 44px;
            }

            /* 사진 확대 */
            .node-photos img:hover {
                transform: scale(1.2);
            }
        }

        /* 아주 작은 화면 (320px 이하) */
        @media (max-width: 320px) {
            .header h1 {
                font-size: 16px;
            }

            .stats-container {
                grid-template-columns: 1fr;
            }

            .tree-node {
                min-width: 100px;
                padding: 10px 12px;
            }

            .header-btn {
                padding: 4px 8px;
                font-size: 11px;
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        /* 확인 다이얼로그 */
        .confirm-dialog {
            position: absolute;
            background: white;
            border: 2px solid #f44336;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 1001;
            display: none;
        }

        .confirm-dialog.show {
            display: block;
        }

        .confirm-dialog p {
            margin-bottom: 15px;
            font-size: 14px;
        }

        .confirm-dialog .buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .confirm-dialog button {
            padding: 4px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        /* 업체정보 모달 스타일 */
        #companyInfoModal .modal-body label {
            display: block;
            margin-top: 10px;
            margin-bottom: 4px;
            font-weight: bold;
            color: #333;
        }

        #companyInfoModal .modal-body input,
        #companyInfoModal .modal-body textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            box-sizing: border-box;
        }

        #companyInfoModal .modal-body textarea {
            height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        #companyInfoModal .modal-body input:first-of-type {
            margin-top: 0;
        }

        #companyInfoModal .modal-body input:focus,
        #companyInfoModal .modal-body textarea:focus {
            border-color: #2196F3;
            outline: none;
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.3);
        }

        /* 반응형 */
        @media (max-width: 768px) {
            .detail-panel {
                width: 100%;
                right: -100%;
            }

            .detail-footer {
                padding-bottom: 60px;
                /* iOS safe area 대응 강화 */
                padding-bottom: calc(60px + env(safe-area-inset-bottom));
            }

            .detail-footer .btn {
                padding: 12px 16px;
                font-size: 15px;
                min-height: 44px;
            }

            .tree-level {
                flex-direction: row;
                overflow-x: auto;
                padding-bottom: 10px;
            }

            .tree-level::-webkit-scrollbar {
                height: 4px;
            }

            .tree-level::-webkit-scrollbar-thumb {
                background: rgba(102, 126, 234, 0.3);
                border-radius: 2px;
            }

            /* 평면도 모달 모바일 최적화 */
            #floorPlanModal .modal-content {
                max-width: 95%;
                max-height: 95vh;
                padding: 10px;
            }

            #floorPlanModalBody {
                flex-direction: column !important;
                gap: 10px !important;
            }

            #floorPlanInputSection {
                flex: none !important;
                width: 100% !important;
                max-height: 35vh !important;
                overflow-y: auto;
                border: 1px solid #ddd;
                border-radius: 6px;
                padding: 10px;
                background: #f9f9f9;
            }

            /* 스마트폰에서 입력 요소 가로 정렬 */
            #floorPlanInputSection > div {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: flex-start;
            }

            #floorPlanInputSection h4 {
                width: 100%;
                font-size: 13px !important;
                margin-bottom: 6px !important;
            }

            #floorPlanInputSection .floorplan-input-group {
                display: inline-flex;
                flex-direction: column;
                gap: 2px;
                min-width: fit-content;
            }

            #floorPlanInputSection label {
                font-size: 11px;
                white-space: nowrap;
            }

            #floorPlanInputSection button {
                font-size: 11px !important;
                padding: 4px 8px !important;
                width: auto !important;
            }

            #floorPlanInputSection select {
                font-size: 11px !important;
                width: 120px !important;
            }

            #floorPlanModal .modal-body > div:last-child {
                flex: 1;
                min-height: 55vh;
            }

            #floorPlanModal canvas {
                width: 100% !important;
                height: 55vh !important;
                touch-action: none;
            }

            #floorPlanModal .modal-footer {
                flex-wrap: wrap;
                gap: 6px;
            }

            #floorPlanModal .modal-footer button {
                flex: 1;
                min-width: calc(50% - 3px);
                padding: 8px 6px;
                font-size: 12px;
            }
        }

        /* 평면도 입력 필드 크기 조정 */
        #floorPlanModal input[type="number"]:not([style*="width: 100%"]) {
            width: 80px;
        }

        /* PC/태블릿 가로 모드 - 입력 섹션 세로 정렬 */
        @media (min-width: 769px) {
            #floorPlanInputSection {
                flex: 0 0 200px !important;
                max-height: 70vh !important;
                border: none !important;
                background: transparent !important;
                padding: 0 !important;
            }

            #floorPlanInputSection > div {
                display: block !important;
            }

            #floorPlanInputSection .floorplan-input-group {
                display: block !important;
                margin-bottom: 8px;
            }

            #floorPlanModalBody {
                flex-direction: row !important;
                gap: 15px !important;
            }

            #floorPlanModal .modal-body > div:last-child {
                min-height: auto;
            }

            #floorPlanModal canvas {
                height: 600px !important;
            }
        }

        /* 태블릿 세로 모드 (768px 이하) */
        @media (max-width: 768px) and (min-width: 481px) {
            #floorPlanInputSection h4 {
                font-size: 14px !important;
            }

            #floorPlanInputSection label {
                font-size: 12px;
            }

            #floorPlanInputSection button {
                font-size: 12px !important;
                padding: 5px 10px !important;
            }

            #floorPlanInputSection select {
                font-size: 12px !important;
                width: 150px !important;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- 메인 콘텐츠 영역 -->
        <div class="content-area">
            <!-- 헤더 -->
            <div class="header">
                <div>
                    <h1>📋 현장조사 체크리스트</h1>
                </div>
                <div class="header-actions">
                    <button class="header-btn" onclick="openCompanyInfo()">📋 기본정보</button>
                    <button class="header-btn" onclick="openFloorPlan()">📐 평면도</button>
                    <button class="header-btn" onclick="importData()">📂 JSON 불러오기</button>
                    <button class="header-btn" onclick="exportData()">📤 JSON 내보내기</button>
                    <button class="header-btn" onclick="generatePhotoIndex()">📷 사진 대조표</button>
                </div>

                <!-- 모바일 햄버거 메뉴 -->
                <div class="mobile-menu-container">
                    <button class="hamburger-btn" onclick="toggleMobileMenu()">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    <div class="mobile-menu-dropdown" id="mobileMenuDropdown">
                        <button class="mobile-menu-btn" onclick="openCompanyInfo(); closeMobileMenu()">📋 기본정보</button>
                        <button class="mobile-menu-btn" onclick="openFloorPlan(); closeMobileMenu()">📐 평면도</button>
                        <button class="mobile-menu-btn" onclick="importData(); closeMobileMenu()">📂 JSON 불러오기</button>
                        <button class="mobile-menu-btn" onclick="exportData(); closeMobileMenu()">📤 JSON 내보내기</button>
                        <button class="mobile-menu-btn" onclick="generatePhotoIndex(); closeMobileMenu()">📷 사진 대조표</button>
                    </div>
                </div>
            </div>

            <!-- 트리 뷰 컨테이너 -->
            <div class="tree-view-container active" id="treeView">


                <!-- 전체 구조 다이어그램 -->
                <div class="structure-overview">
                    <h2 class="structure-title" style="font-size: 20px; font-weight: 600; margin-bottom: 20px; color: #333;">
                        🌳 전력계통
                    </h2>
                    
                    <div class="tree-diagram" id="treeDiagram">
                        <!-- SVG 캔버스 -->
                        <svg class="tree-svg" id="treeSvg"></svg>
                        
                        <!-- Level 1: 한전 수전 -->
                        <div class="tree-level tree-level-1" id="level1">
                            <div class="tree-node" id="kepco" onclick="showNodeDetail('kepco')" style="background: #f3e5f5;">
                                <div class="node-title">한전 수전</div>
                                <div class="node-info">-</div>
                                <div class="node-status empty">-</div>
                                <div class="node-photos" id="photos-kepco"></div>
                            </div>
                        </div>

                        <!-- Level 2: 변압기 -->
                        <div class="tree-level tree-level-2" id="level2">
                            <!-- 변압기 추가 버튼 -->
                            <div class="tree-node add-node" onclick="addTransformer()">
                                <div class="node-title">➕ 변압기 추가</div>
                                <div class="node-info">클릭하여 추가</div>
                            </div>
                        </div>

                        <!-- Level 3: 분전반 -->
                        <div class="tree-level tree-level-3" id="level3">
                            <!-- MCC 추가 버튼 -->
                            <div class="tree-node add-node" onclick="addMCC()">
                                <div class="node-title">➕ 분전반 추가</div>
                                <div class="node-info">변압기 선택 후 추가</div>
                            </div>
                        </div>

                        <!-- Level 4: 주요 부하 -->
                        <div class="tree-level tree-level-4" id="level4">
                            <!-- 부하 추가 버튼 -->
                            <div class="tree-node add-node" onclick="addLoad()">
                                <div class="node-title">➕ 부하 추가</div>
                                <div class="node-info">분전반 선택 후 추가</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 상세 정보 패널 -->
        <div class="detail-panel" id="detailPanel">
            <div class="detail-header">
                <h2 id="detailTitle">상세 정보</h2>
                <button class="close-btn" onclick="closeDetail()">×</button>
            </div>
            <div class="detail-content" id="detailContent">
                <!-- 동적 콘텐츠 -->
            </div>
        </div>


        <!-- 추가 모달 -->
        <div class="modal" id="addModal">
            <div class="modal-content">
                <div class="modal-header" id="modalTitle">항목 추가</div>
                <div class="modal-body" id="modalBody">
                    <!-- 동적 콘텐츠 -->
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeModal()">취소</button>
                    <button class="btn btn-primary" onclick="confirmAdd()">추가</button>
                </div>
            </div>
        </div>

        <!-- 삭제 확인 다이얼로그 -->
        <div class="confirm-dialog" id="deleteConfirm">
            <p>정말 삭제하시겠습니까?</p>
            <div class="buttons">
                <button onclick="cancelDelete()" style="background: #e0e0e0;">취소</button>
                <button onclick="confirmDelete()" style="background: #f44336; color: white;">삭제</button>
            </div>
        </div>

        <!-- 업체정보 모달 -->
        <div class="modal" id="companyInfoModal">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h3>📋 업체 기본정보</h3>
                    <span class="close" onclick="closeCompanyInfo()">&times;</span>
                </div>
                <div class="modal-body" id="companyInfoBody">
                    <label>업체명</label>
                    <input type="text" id="companyName" placeholder="업체명을 입력하세요">

                    <label>주소</label>
                    <input type="text" id="companyAddress" placeholder="업체 주소">

                    <label>담당자</label>
                    <input type="text" id="companyManager" placeholder="담당자명">

                    <label>연락처</label>
                    <input type="text" id="companyContact" placeholder="전화번호">

                    <label>조사일자</label>
                    <input type="date" id="surveyDate">

                    <label>비고</label>
                    <textarea id="companyNotes" placeholder="기타 메모"></textarea>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeCompanyInfo()">취소</button>
                    <button class="btn btn-primary" onclick="saveCompanyInfo()">저장</button>
                </div>
            </div>
        </div>

        <!-- 평면도 모달 -->
        <div class="modal" id="floorPlanModal">
            <div class="modal-content" style="max-width: 1200px; max-height: 90vh;">
                <div class="modal-header">
                    <h3>📐 설치 위치 평면도</h3>
                    <span class="close" onclick="closeFloorPlan()">&times;</span>
                </div>
                <div class="modal-body" id="floorPlanModalBody" style="display: flex; gap: 15px;">
                    <!-- 좌측: 입력 패널 -->
                    <div id="floorPlanInputSection" style="flex: 0 0 200px; overflow-y: auto; max-height: 70vh;">
                        <div style="margin-bottom: 12px;">
                            <h4 style="margin-bottom: 8px; font-size: 14px;">🏢 공간 정보</h4>
                            <div class="floorplan-input-group">
                                <label>가로(mm)</label>
                                <input type="number" id="roomWidth" placeholder="8000" value="8000" onchange="updateFloorPlan()" inputmode="numeric" pattern="[0-9]*" style="width: 80px;">
                            </div>
                            <div class="floorplan-input-group">
                                <label>세로(mm)</label>
                                <input type="number" id="roomLength" placeholder="6000" value="6000" onchange="updateFloorPlan()" inputmode="numeric" pattern="[0-9]*" style="width: 80px;">
                            </div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <h4 style="margin-bottom: 8px; font-size: 14px;">🚪 출입구</h4>
                            <button class="btn btn-secondary" onclick="addDoor()" style="font-size: 12px; width: 100%;">출입구 추가</button>
                            <div id="doorsList"></div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <h4 style="margin-bottom: 8px; font-size: 14px;">⚡ 기존 설비</h4>
                            <button class="btn btn-secondary" onclick="addExistingEquipment()" style="font-size: 12px; width: 100%;">기존설비 추가</button>
                            <div id="existingEquipmentList"></div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <h4 style="margin-bottom: 8px; font-size: 14px;">🔧 설치 제품</h4>
                            <label style="font-size: 12px;">제품 선택</label>
                            <select id="reactorProductSelect" style="width: 100%; font-size: 12px; margin-bottom: 4px;">
                                <option value="">제품 선택</option>
                                <option value="30kVA">30kVA</option>
                                <option value="50kVA">50kVA</option>
                                <option value="75kVA">75kVA</option>
                                <option value="100kVA">100kVA</option>
                                <option value="150kVA">150kVA</option>
                                <option value="200kVA">200kVA</option>
                                <option value="300-400kVA">300~400kVA</option>
                                <option value="500-800kVA">500~800kVA</option>
                                <option value="900-1000kVA">900~1000kVA</option>
                            </select>
                            <button class="btn btn-secondary" onclick="addReactorProduct()" style="font-size: 12px; width: 100%;">제품 추가</button>
                            <div id="reactorProductsList"></div>
                        </div>
                    </div>

                    <!-- 우측: 평면도 캔버스 -->
                    <div style="flex: 1; border: 1px solid #ddd; position: relative; overflow: auto;">
                        <canvas id="floorPlanCanvas" width="800" height="600" style="width: 100%; height: 600px; cursor: crosshair; min-width: 600px; min-height: 500px;"></canvas>
                        <div style="position: absolute; bottom: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 5px; border-radius: 3px; font-size: 12px;">
                            <div>축척: <span id="scaleDisplay">1:100</span></div>
                            <div>격자: <span id="gridDisplay">100mm</span></div>
                        </div>

                        <div style="position: absolute; bottom: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 5px; border-radius: 3px; font-size: 11px; max-width: 200px;">
                            <div><strong>사용법:</strong></div>
                            <div>• 클릭 & 드래그: 객체 이동</div>
                            <div>• Shift + 드래그: 자유 이동</div>
                            <div>• 일반 드래그: 100mm 스냅</div>
                            <div style="margin-top: 3px;">
                                <span style="color: #4CAF50;">■</span> 리액터
                                <span style="color: #FF9800;">■</span> 기존설비
                                <span style="color: #4CAF50;">━</span> 출입구
                            </div>
                            <div style="margin-top: 3px; font-size: 9px; color: #666;">
                                격자: 100mm(옅음) / 500mm / 1m(진함)
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="resetFloorPlanZoom()">축척 리셋</button>
                    <button class="btn btn-secondary" onclick="resetFloorPlan()">초기화</button>
                    <button class="btn btn-secondary" onclick="exportFloorPlan()">PDF 출력</button>
                    <button class="btn btn-secondary" onclick="closeFloorPlan()">취소</button>
                    <button class="btn btn-primary" onclick="saveFloorPlan()">저장</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 전역 데이터 저장소
        let systemData = {
            companyInfo: {
                name: '',
                address: '',
                contact: '',
                manager: '',
                surveyDate: '',
                notes: ''
            },
            kepco: {
                voltage: '22.9kV',
                contractPower: '',
                breaker: '',
                receptionType: '',
                vcb: '',
                status: 'empty'
            },
            transformers: {},
            panels: {},
            loads: {},
            images: {}, // 사진 저장용 (nodeId: [base64Images...])
            connections: {
                transformerToPanels: {},
                panelToLoads: {}
            },
            floorPlan: {
                enabled: false,
                roomDimensions: {
                    width: 0,   // 가로 (mm)
                    length: 0,  // 세로 (mm)
                    height: 0   // 높이 (mm)
                },
                doors: [], // {x: number, y: number, width: number, orientation: 'horizontal'|'vertical'}
                existingEquipment: [], // {id: string, x: number, y: number, width: number, length: number, name: string}
                reactorProducts: [], // {id: string, x: number, y: number, productId: string, rotation: number}
                scale: 1, // mm per pixel
                gridSize: 100, // mm (100mm 간격)
                safetyMargins: {
                    front: 800,    // 전면 여유공간 (mm)
                    back: 600,     // 후면 여유공간 (mm)
                    side: 400      // 측면 여유공간 (mm)
                }
            }
        };

        // 몰드변압기 제품 데이터베이스
        const reactorProductDB = {
            '30kVA': {
                name: '30kVA',
                capacity: 30,
                dimensions: { width: 500, length: 310, height: 760 },
                weight: 62,
                safetyMargins: { front: 0, back: 0, side: 0 }
            },
            '50kVA': {
                name: '50kVA',
                capacity: 50,
                dimensions: { width: 600, length: 380, height: 950 },
                weight: 100,
                safetyMargins: { front: 0, back: 0, side: 0 }
            },
            '75kVA': {
                name: '75kVA',
                capacity: 75,
                dimensions: { width: 750, length: 410, height: 1200 },
                weight: 145,
                safetyMargins: { front: 0, back: 0, side: 0 }
            },
            '100kVA': {
                name: '100kVA',
                capacity: 100,
                dimensions: { width: 820, length: 530, height: 1280 },
                weight: 188,
                safetyMargins: { front: 0, back: 0, side: 0 }
            },
            '150kVA': {
                name: '150kVA',
                capacity: 150,
                dimensions: { width: 945, length: 500, height: 1530 },
                weight: 280,
                safetyMargins: { front: 0, back: 0, side: 0 }
            },
            '200kVA': {
                name: '200kVA',
                capacity: 200,
                dimensions: { width: 950, length: 500, height: 1530 },
                weight: 300,
                safetyMargins: { front: 0, back: 0, side: 0 }
            },
            '300-400kVA': {
                name: '300~400kVA',
                capacity: 350,
                dimensions: { width: 750, length: 930, height: 1850 },
                weight: 335,
                safetyMargins: { front: 0, back: 0, side: 0 }
            },
            '500-800kVA': {
                name: '500~800kVA',
                capacity: 650,
                dimensions: { width: 880, length: 1130, height: 1900 },
                weight: 850,
                safetyMargins: { front: 0, back: 0, side: 0 }
            },
            '900-1000kVA': {
                name: '900~1000kVA',
                capacity: 950,
                dimensions: { width: 950, length: 1130, height: 2050 },
                weight: 1250,
                safetyMargins: { front: 0, back: 0, side: 0 }
            }
        };

        // 카운터
        let transformerCounter = 0;
        let mccCounter = 0;
        let loadCounter = 0;

        // 선택된 항목
        let selectedNode = null;
        let selectedTransformer = null;
        let selectedPanel = null;
        let nodeToDelete = null;
        let currentModalType = null;

        // 유틸리티 함수들
        function getTransformerNumber(transformerId) {
            // transformer1 -> 1
            return parseInt(transformerId.replace('transformer', ''));
        }

        function getPanelNumbers(panelTitle) {
            // 분전1-2 -> [1, 2]
            const match = panelTitle.match(/분전(\d+)-(\d+)/);
            return match ? [parseInt(match[1]), parseInt(match[2])] : [0, 0];
        }

        function getLoadNumbers(loadTitle) {
            // 부하1-2-3 -> [1, 2, 3]
            const match = loadTitle.match(/부하(\d+)-(\d+)-(\d+)/);
            return match ? [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])] : [0, 0, 0];
        }

        function sortNodesByNumber(container, getNumbers) {
            const nodes = Array.from(container.children).filter(node => !node.classList.contains('add-node'));
            const addButton = container.querySelector('.add-node');

            // 번호 기준으로 정렬
            nodes.sort((a, b) => {
                const aData = systemData.transformers[a.id] || systemData.panels[a.id] || systemData.loads[a.id];
                const bData = systemData.transformers[b.id] || systemData.panels[b.id] || systemData.loads[b.id];

                const aNumbers = getNumbers(aData.title);
                const bNumbers = getNumbers(bData.title);

                // 배열 비교 (첫 번째 요소부터 순서대로)
                for (let i = 0; i < Math.max(aNumbers.length, bNumbers.length); i++) {
                    const aNum = aNumbers[i] || 0;
                    const bNum = bNumbers[i] || 0;
                    if (aNum !== bNum) return aNum - bNum;
                }
                return 0;
            });

            // DOM에서 기존 노드들 제거
            nodes.forEach(node => container.removeChild(node));

            // 정렬된 순서로 다시 추가
            nodes.forEach(node => container.insertBefore(node, addButton));
        }

        // 변압기 추가
        function addTransformer() {
            transformerCounter++;
            const trId = 'transformer' + transformerCounter;

            // 기본값으로 변압기 추가
            systemData.transformers[trId] = {
                id: trId,
                title: `변압기${transformerCounter}`,
                name: `주변압기 #${transformerCounter}`,
                capacity: '',
                voltage: '',
                breaker: '',
                primaryVoltage: 22900,
                secondaryVoltage: '380/220',
                type: 'Oil',
                status: 'empty'
            };

            // DOM에 노드 추가
            addTransformerNode(trId);
            updateStatistics();
            redrawConnections();

            // 자동 스케일 조정
            setTimeout(() => {
                autoScaleTree();
            }, 100);
        }

        // MCC 추가
        function addMCC() {
            // 변압기가 있는지 확인
            if (Object.keys(systemData.transformers).length === 0) {
                alert('먼저 변압기를 추가해주세요.');
                return;
            }

            // 변압기가 1개면 자동 연결, 여러 개면 선택
            const transformerIds = Object.keys(systemData.transformers);
            if (transformerIds.length === 1) {
                // 변압기가 1개면 바로 추가
                addMCCToTransformer(transformerIds[0]);
            } else {
                // 변압기가 여러 개면 선택 모달 표시
                showTransformerSelectionModal();
            }
        }

        function showTransformerSelectionModal() {
            // 선택 모달 생성
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 20px;
                border-radius: 10px;
                max-width: 400px;
                width: 90%;
            `;

            let html = '<h3>연결할 변압기를 선택하세요</h3><div style="margin: 15px 0;">';

            Object.keys(systemData.transformers).forEach(trId => {
                const tr = systemData.transformers[trId];
                html += `
                    <button style="
                        display: block;
                        width: 100%;
                        padding: 10px;
                        margin: 5px 0;
                        border: 1px solid #ddd;
                        background: #f9f9f9;
                        border-radius: 5px;
                        cursor: pointer;
                        text-align: left;
                    " onclick="selectTransformer('${trId}')">
                        🔌 ${tr.title} (${tr.capacity}kVA)
                    </button>
                `;
            });

            html += `</div>
                <button style="
                    padding: 8px 16px;
                    background: #ccc;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    float: right;
                " onclick="closeSelectionModal()">취소</button>
            `;

            modalContent.innerHTML = html;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // 전역에서 접근 가능하도록 저장
            window.currentSelectionModal = modal;
        }

        function selectTransformer(transformerId) {
            addMCCToTransformer(transformerId);
            closeSelectionModal();
        }

        function closeSelectionModal() {
            if (window.currentSelectionModal) {
                document.body.removeChild(window.currentSelectionModal);
                window.currentSelectionModal = null;
            }
        }

        function addMCCToTransformer(transformerId) {
            const transformerNumber = getTransformerNumber(transformerId);

            // 해당 변압기에 연결된 기존 분전반 개수 계산
            const existingPanels = systemData.connections.transformerToPanels[transformerId] || [];
            const panelSequence = existingPanels.length + 1;

            mccCounter++;
            const mccId = 'mcc' + mccCounter;

            // 계층적 번호 체계로 분전반 추가 (X-Y 형식)
            systemData.panels[mccId] = {
                id: mccId,
                title: `분전${transformerNumber}-${panelSequence}`,
                name: `MCC-${transformerNumber}-${panelSequence} 동력반`,
                ratedCurrent: 2000,
                purpose: '동력반',
                status: 'empty'
            };

            // 연결정보 업데이트
            if (!systemData.connections.transformerToPanels[transformerId]) {
                systemData.connections.transformerToPanels[transformerId] = [];
            }
            systemData.connections.transformerToPanels[transformerId].push(mccId);

            // DOM에 노드 추가
            addMCCNode(mccId);
            updateStatistics();
            redrawConnections();

            // 자동 스케일 조정
            setTimeout(() => {
                autoScaleTree();
            }, 100);
        }

        // 부하 추가
        function addLoad() {
            // 분전반이 있는지 확인
            if (Object.keys(systemData.panels).length === 0) {
                alert('먼저 분전반을 추가해주세요.');
                return;
            }

            // 분전반이 1개면 자동 연결, 여러 개면 선택
            const panelIds = Object.keys(systemData.panels);
            if (panelIds.length === 1) {
                // 분전반이 1개면 바로 추가
                addLoadToPanel(panelIds[0]);
            } else {
                // 분전반이 여러 개면 선택 모달 표시
                showPanelSelectionModal();
            }
        }

        function showPanelSelectionModal() {
            // 선택 모달 생성
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                padding: 20px;
                border-radius: 10px;
                max-width: 400px;
                width: 90%;
            `;

            let html = '<h3>연결할 분전반을 선택하세요</h3><div style="margin: 15px 0;">';

            Object.keys(systemData.panels).forEach(panelId => {
                const panel = systemData.panels[panelId];
                html += `
                    <button style="
                        display: block;
                        width: 100%;
                        padding: 10px;
                        margin: 5px 0;
                        border: 1px solid #ddd;
                        background: #f9f9f9;
                        border-radius: 5px;
                        cursor: pointer;
                        text-align: left;
                    " onclick="selectPanel('${panelId}')">
                        📊 ${panel.title} (${panel.ratedCurrent}A)
                    </button>
                `;
            });

            html += `</div>
                <button style="
                    padding: 8px 16px;
                    background: #ccc;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    float: right;
                " onclick="closeSelectionModal()">취소</button>
            `;

            modalContent.innerHTML = html;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // 전역에서 접근 가능하도록 저장
            window.currentSelectionModal = modal;
        }

        function selectPanel(panelId) {
            addLoadToPanel(panelId);
            closeSelectionModal();
        }

        function addLoadToPanel(panelId) {
            const panel = systemData.panels[panelId];
            const panelNumbers = getPanelNumbers(panel.title); // [변압기번호, 분전반번호]

            // 해당 분전반에 연결된 기존 부하 개수 계산
            const existingLoads = systemData.connections.panelToLoads[panelId] || [];
            const loadSequence = existingLoads.length + 1;

            loadCounter++;
            const loadId = 'load' + loadCounter;

            // 계층적 번호 체계로 부하 추가 (X-Y-Z 형식)
            systemData.loads[loadId] = {
                id: loadId,
                title: `부하${panelNumbers[0]}-${panelNumbers[1]}-${loadSequence}`,
                name: `냉동기`,
                power: 500,
                quantity: 1,
                type: '',
                loadRate: '',
                notes: '',
                status: 'empty'
            };

            // 연결정보 업데이트
            if (!systemData.connections.panelToLoads[panelId]) {
                systemData.connections.panelToLoads[panelId] = [];
            }
            systemData.connections.panelToLoads[panelId].push(loadId);

            // DOM에 노드 추가
            addLoadNode(loadId);
            updateStatistics();
            redrawConnections();

            // 자동 스케일 조정
            setTimeout(() => {
                autoScaleTree();
            }, 100);
        }

        // 추가 확인
        function confirmAdd() {
            if (currentModalType === 'transformer') {
                const name = document.getElementById('newTrName').value || `변압기 #${transformerCounter + 1}`;
                const capacity = parseInt(document.getElementById('newTrCapacity').value) || 1000;
                const primaryV = parseInt(document.getElementById('newTrPrimaryV').value) || 22900;
                const secondaryV = document.getElementById('newTrSecondaryV').value;
                const type = document.getElementById('newTrType').value;
                
                transformerCounter++;
                const trId = `tr${transformerCounter}`;
                
                systemData.transformers[trId] = {
                    id: trId,
                    title: name,
                    capacity: capacity,
                    voltage: secondaryV,
                    primaryVoltage: primaryV,
                    secondaryVoltage: secondaryV,
                    type: type,
                    status: 'empty'
                };
                
                // DOM에 노드 추가
                addTransformerNode(trId);
                
            } else if (currentModalType === 'mcc') {
                const transformerId = document.getElementById('newMccTransformer').value;
                if (!transformerId) {
                    alert('변압기를 선택해주세요.');
                    return;
                }
                
                const name = document.getElementById('newMccName').value || `MCC-${mccCounter + 1}`;
                const breaker = parseInt(document.getElementById('newMccBreaker').value) || 1000;
                const purpose = document.getElementById('newMccPurpose').value;

                mccCounter++;
                const mccId = `mcc${mccCounter}`;

                systemData.panels[mccId] = {
                    id: mccId,
                    title: name,
                    transformer: transformerId,
                    mainBreaker: breaker,
                    purpose: purpose,
                    status: 'empty'
                };
                
                // 연결 정보 저장
                if (!systemData.connections.transformerToPanels[transformerId]) {
                    systemData.connections.transformerToPanels[transformerId] = [];
                }
                systemData.connections.transformerToPanels[transformerId].push(mccId);
                
                // DOM에 노드 추가
                addMCCNode(mccId);
                
            } else if (currentModalType === 'load') {
                const panelId = document.getElementById('newLoadPanel').value;
                if (!panelId) {
                    alert('분전반을 선택해주세요.');
                    return;
                }
                
                const name = document.getElementById('newLoadName').value || `부하 #${loadCounter + 1}`;
                const capacity = parseInt(document.getElementById('newLoadCapacity').value) || 100;
                const quantity = parseInt(document.getElementById('newLoadQuantity').value) || 1;
                const type = document.getElementById('newLoadType').value;
                const operation = document.getElementById('newLoadOperation').value;
                
                loadCounter++;
                const loadId = `load${loadCounter}`;
                
                systemData.loads[loadId] = {
                    id: loadId,
                    title: name,
                    panel: panelId,
                    capacity: capacity,
                    quantity: quantity,
                    type: type,
                    loadRate: '',
                    notes: '',
                    status: 'empty'
                };
                
                // 연결 정보 저장
                if (!systemData.connections.panelToLoads[panelId]) {
                    systemData.connections.panelToLoads[panelId] = [];
                }
                systemData.connections.panelToLoads[panelId].push(loadId);
                
                // DOM에 노드 추가
                addLoadNode(loadId);
            }
            
            closeModal();
            updateStatistics();
            redrawConnections();
        }

        // 변압기 노드 DOM 추가
        function addTransformerNode(trId) {
            const level2 = document.getElementById('level2');
            const addBtn = level2.querySelector('.add-node');

            const node = document.createElement('div');
            node.className = 'tree-node';
            node.id = trId;
            node.onclick = () => openDetail(trId);

            const tr = systemData.transformers[trId];

            // 변압기 정보 구성
            let infoLines = [];
            if (tr.capacity && tr.capacity !== '') {
                infoLines.push(`${tr.capacity}kVA`);
            }
            if (tr.voltage && tr.voltage !== '') {
                infoLines.push(`${tr.voltage}V`);
            }
            if (tr.breaker && tr.breaker !== '') {
                infoLines.push(`${tr.breaker}A`);
            }

            let capacityInfo = infoLines.length > 0 ? infoLines.join(' / ') : '-';
            let capacityClass = infoLines.length === 0 ? ' missing' : '';

            node.innerHTML = `
                <div class="node-actions">
                    <button class="node-action-btn edit" onclick="event.stopPropagation(); openDetail('${trId}')">✎</button>
                    <button class="node-action-btn delete" onclick="event.stopPropagation(); deleteNode('${trId}', 'transformer')">×</button>
                </div>
                <div class="node-title">${tr.title}</div>
                <div class="node-info${capacityClass}">${capacityInfo}</div>
                <div class="node-status ${tr.status}">${tr.status === 'complete' ? '✓' : tr.status === 'incomplete' ? '!' : '-'}</div>
                <div class="node-photos" id="photos-${trId}"></div>
            `;

            level2.insertBefore(node, addBtn);

            // 변압기 노드들을 번호 순서대로 자동 정렬
            function getTransformerNumbers(title) {
                const match = title.match(/변압기(\d+)/);
                return match ? [parseInt(match[1])] : [0];
            }
            sortNodesByNumber(level2, getTransformerNumbers);
        }

        // MCC 노드 DOM 추가
        function addMCCNode(mccId) {
            const level3 = document.getElementById('level3');
            const addBtn = level3.querySelector('.add-node');

            const node = document.createElement('div');
            node.className = 'tree-node';
            node.id = mccId;
            node.onclick = () => openDetail(mccId);

            const mcc = systemData.panels[mccId];

            // 주차단기 정보 확인
            let breakerInfo = '';
            let breakerClass = '';
            if (mcc.mainBreaker && mcc.mainBreaker !== '') {
                breakerInfo = `${mcc.mainBreaker}A`;
            } else {
                breakerInfo = '-';
                breakerClass = ' missing';
            }

            node.innerHTML = `
                <div class="node-actions">
                    <button class="node-action-btn edit" onclick="event.stopPropagation(); openDetail('${mccId}')">✎</button>
                    <button class="node-action-btn delete" onclick="event.stopPropagation(); deleteNode('${mccId}', 'mcc')">×</button>
                </div>
                <div class="node-title">${mcc.title}</div>
                <div class="node-info${breakerClass}">${breakerInfo}</div>
                <div class="node-status ${mcc.status}">${mcc.status === 'complete' ? '✓' : mcc.status === 'incomplete' ? '!' : '-'}</div>
                <div class="node-photos" id="photos-${mccId}"></div>
            `;

            level3.insertBefore(node, addBtn);

            // 분전반 노드들을 번호 순서대로 자동 정렬
            sortNodesByNumber(level3, getPanelNumbers);
        }

        // 부하 노드 DOM 추가
        function addLoadNode(loadId) {
            const level4 = document.getElementById('level4');
            const addBtn = level4.querySelector('.add-node');

            const node = document.createElement('div');
            node.className = 'tree-node';
            node.id = loadId;
            node.onclick = () => openDetail(loadId);

            const load = systemData.loads[loadId];

            // 부하 정보 구성
            let infoLines = [];
            if (load.type && load.type !== '') {
                infoLines.push(load.type);
            }
            if (load.loadRate && load.loadRate !== '') {
                infoLines.push(`${load.loadRate}%`);
            }

            let capacityInfo = infoLines.length > 0 ? infoLines.join(' / ') : '-';
            let capacityClass = infoLines.length === 0 ? ' missing' : '';

            node.innerHTML = `
                <div class="node-actions">
                    <button class="node-action-btn edit" onclick="event.stopPropagation(); openDetail('${loadId}')">✎</button>
                    <button class="node-action-btn delete" onclick="event.stopPropagation(); deleteNode('${loadId}', 'load')">×</button>
                </div>
                <div class="node-title">${load.title}</div>
                <div class="node-info${capacityClass}">${capacityInfo}</div>
                <div class="node-status ${load.status}">${load.status === 'complete' ? '✓' : load.status === 'incomplete' ? '!' : '-'}</div>
                <div class="node-photos" id="photos-${loadId}"></div>
            `;

            level4.insertBefore(node, addBtn);

            // 부하 노드들을 번호 순서대로 자동 정렬
            sortNodesByNumber(level4, getLoadNumbers);
        }

        // 노드 삭제
        function deleteNode(nodeId, type) {
            nodeToDelete = { id: nodeId, type: type };
            
            const dialog = document.getElementById('deleteConfirm');
            const node = document.getElementById(nodeId);
            
            // 다이얼로그 위치 설정
            const rect = node.getBoundingClientRect();
            dialog.style.top = rect.top + 'px';
            dialog.style.left = (rect.left - 200) + 'px';
            
            dialog.classList.add('show');
        }

        // 삭제 확인
        function confirmDelete() {
            if (!nodeToDelete) return;
            
            const { id, type } = nodeToDelete;
            
            if (type === 'transformer') {
                // 연결된 MCC들도 삭제
                const connectedPanels = systemData.connections.transformerToPanels[id] || [];
                connectedPanels.forEach(panelId => {
                    // 연결된 부하들도 삭제
                    const connectedLoads = systemData.connections.panelToLoads[panelId] || [];
                    connectedLoads.forEach(loadId => {
                        document.getElementById(loadId)?.remove();
                        delete systemData.loads[loadId];
                    });
                    delete systemData.connections.panelToLoads[panelId];
                    
                    document.getElementById(panelId)?.remove();
                    delete systemData.panels[panelId];
                });
                delete systemData.connections.transformerToPanels[id];
                
                delete systemData.transformers[id];
                
            } else if (type === 'mcc') {
                // 연결된 부하들도 삭제
                const connectedLoads = systemData.connections.panelToLoads[id] || [];
                connectedLoads.forEach(loadId => {
                    document.getElementById(loadId)?.remove();
                    delete systemData.loads[loadId];
                });
                delete systemData.connections.panelToLoads[id];
                
                // 변압기 연결 정보에서 제거
                Object.keys(systemData.connections.transformerToPanels).forEach(trId => {
                    const panels = systemData.connections.transformerToPanels[trId];
                    const index = panels.indexOf(id);
                    if (index > -1) {
                        panels.splice(index, 1);
                    }
                });
                
                delete systemData.panels[id];
                
            } else if (type === 'load') {
                // 분전반 연결 정보에서 제거
                Object.keys(systemData.connections.panelToLoads).forEach(panelId => {
                    const loads = systemData.connections.panelToLoads[panelId];
                    const index = loads.indexOf(id);
                    if (index > -1) {
                        loads.splice(index, 1);
                    }
                });
                
                delete systemData.loads[id];
            }
            
            // DOM에서 제거
            document.getElementById(id)?.remove();
            
            cancelDelete();
            updateStatistics();
            redrawConnections();
        }

        // 삭제 취소
        function cancelDelete() {
            document.getElementById('deleteConfirm').classList.remove('show');
            nodeToDelete = null;
        }

        // showNodeDetail 함수 (openDetail의 별칭)
        function showNodeDetail(nodeId) {
            openDetail(nodeId);
        }

        // 상세 정보 열기
        function openDetail(nodeId) {
            const panel = document.getElementById('detailPanel');
            const content = document.getElementById('detailContent');
            const title = document.getElementById('detailTitle');
            
            // 노드 선택 표시
            document.querySelectorAll('.tree-node').forEach(node => {
                node.classList.remove('selected');
            });
            const currentNode = document.getElementById(nodeId);
            if (currentNode) {
                currentNode.classList.add('selected');
            }
            selectedNode = nodeId;
            
            let detailHTML = '';
            
            if (nodeId === 'kepco') {
                title.textContent = '한전 수전 설비';
                detailHTML = `
                    <div class="detail-form-group">
                        <label>수전 전압</label>
                        <select class="detail-form-control" id="kepcoVoltage">
                            <option>22.9kV</option>
                            <option>6.6kV</option>
                            <option>154kV</option>
                            <option>380V</option>
                        </select>
                    </div>
                    <div class="detail-form-group">
                        <label>계약전력 (kW)</label>
                        <input type="number" class="detail-form-control" id="kepcoContract" value="${systemData.kepco.contractPower || ''}" inputmode="numeric" pattern="[0-9]*" placeholder="">
                    </div>
                    <div class="detail-form-group">
                        <label>차단기 (A)</label>
                        <input type="number" class="detail-form-control" id="kepcoBreaker" value="${systemData.kepco.breaker || ''}" inputmode="numeric" pattern="[0-9]*" placeholder="">
                    </div>
                    <div class="detail-form-group">
                        <label>현장 사진</label>
                        <button class="photo-btn" onclick="addPhoto('kepco')">📸 사진 촬영</button>
                        <div class="node-photos" id="detail-photos-kepco" style="margin-top: 10px; max-width: 100%;"></div>
                    </div>
                `;
            } else if (nodeId.startsWith('tr')) {
                const tr = systemData.transformers[nodeId];
                if (!tr) return;
                
                title.textContent = tr.title;
                detailHTML = `
                    <div class="detail-form-group">
                        <label>변압기 명칭</label>
                        <input type="text" class="detail-form-control" id="editTrName" value="${tr.title}">
                    </div>
                    <div class="detail-form-group">
                        <label>용량 (kVA)</label>
                        <input type="number" class="detail-form-control" id="editTrCapacity" value="${tr.capacity || ''}" placeholder="" inputmode="numeric" pattern="[0-9]*">
                    </div>
                    <div class="detail-form-group">
                        <label>전압 (V)</label>
                        <input type="text" class="detail-form-control" id="editTrVoltage" value="${tr.voltage || ''}" placeholder="">
                    </div>
                    <div class="detail-form-group">
                        <label>차단기 (A)</label>
                        <input type="number" class="detail-form-control" id="editTrBreaker" value="${tr.breaker || ''}" inputmode="numeric" pattern="[0-9]*" placeholder="">
                    </div>
                    <div class="detail-form-group">
                        <label>현장 사진</label>
                        <button class="photo-btn" onclick="addPhoto('${nodeId}')">📸 사진 촬영</button>
                        <button class="photo-btn" onclick="addPhoto('${nodeId}', 'breaker-label')" style="margin-left: 5px;">🏷️ 차단기 라벨</button>
                        <button class="photo-btn" onclick="addPhoto('${nodeId}', 'transformer-config')" style="margin-left: 5px;">⚙️ 변압기 구성</button>
                        <div class="node-photos" id="detail-photos-${nodeId}" style="margin-top: 10px; max-width: 100%;"></div>
                    </div>
                `;
            } else if (nodeId.startsWith('mcc')) {
                const mcc = systemData.panels[nodeId];
                if (!mcc) return;
                
                title.textContent = mcc.title;
                detailHTML = `
                    <div class="detail-form-group">
                        <label>분전반 명칭</label>
                        <input type="text" class="detail-form-control" id="editMccName" value="${mcc.title}">
                    </div>
                    <div class="detail-form-group">
                        <label>주차단기 (A)</label>
                        <input type="number" class="detail-form-control" id="editMccBreaker" value="${mcc.mainBreaker}" inputmode="numeric" pattern="[0-9]*">
                    </div>
                    <div class="detail-form-group">
                        <label>현장 사진</label>
                        <button class="photo-btn" onclick="addPhoto('${nodeId}')">📸 사진 촬영</button>
                        <button class="photo-btn" onclick="addPhoto('${nodeId}', 'breaker-label')" style="margin-left: 5px;">🏷️ 차단기 라벨</button>
                        <button class="photo-btn" onclick="addPhoto('${nodeId}', 'panel-config')" style="margin-left: 5px;">📋 분전반 구성</button>
                        <div class="node-photos" id="detail-photos-${nodeId}" style="margin-top: 10px; max-width: 100%;"></div>
                    </div>
                `;
            } else if (nodeId.startsWith('load')) {
                const load = systemData.loads[nodeId];
                if (!load) return;
                
                title.textContent = load.title;
                detailHTML = `
                    <div class="detail-form-group">
                        <label>부하 명칭</label>
                        <input type="text" class="detail-form-control" id="editLoadName" value="${load.title}">
                    </div>
                    <div class="detail-form-group">
                        <label>부하 종류</label>
                        <input type="text" class="detail-form-control" id="editLoadType" value="${load.type || ''}" placeholder="">
                    </div>
                    <div class="detail-form-group">
                        <label>부하율 (%)</label>
                        <input type="number" class="detail-form-control" id="editLoadRate" value="${load.loadRate || ''}" min="0" max="100" inputmode="numeric" pattern="[0-9]*" placeholder="">
                    </div>
                    <div class="detail-form-group">
                        <label>특이사항</label>
                        <textarea class="detail-form-control" id="editLoadNotes" placeholder="" style="min-height: 60px; resize: vertical;">${load.notes || ''}</textarea>
                    </div>
                    <div class="detail-form-group">
                        <label>현장 사진</label>
                        <button class="photo-btn" onclick="addPhoto('${nodeId}')">📸 사진 촬영</button>
                        <div class="node-photos" id="detail-photos-${nodeId}" style="margin-top: 10px; max-width: 100%;"></div>
                    </div>
                `;
            }
            
            content.innerHTML = detailHTML;

            // Footer 영역에 저장 버튼 추가
            const footerHTML = `
                <button class="btn btn-success" style="width: 100%;" onclick="saveNodeData('${nodeId}')">
                    💾 저장
                </button>
            `;

            // footer가 없으면 생성
            let footer = panel.querySelector('.detail-footer');
            if (!footer) {
                footer = document.createElement('div');
                footer.className = 'detail-footer';
                panel.appendChild(footer);
            }
            footer.innerHTML = footerHTML;

            panel.classList.add('open');

            // 상세 패널에서 사진 표시 업데이트
            setTimeout(() => {
                updateDetailPhotoDisplay(nodeId);
                redrawConnections(); // 패널 열림 후 연결선 다시 그리기
            }, 100);
        }

        // 노드 데이터 저장
        function saveNodeData(nodeId) {
            if (nodeId === 'kepco') {
                systemData.kepco.contractPower = parseInt(document.getElementById('kepcoContract').value) || '';
                systemData.kepco.voltage = document.getElementById('kepcoVoltage').value;
                systemData.kepco.breaker = parseInt(document.getElementById('kepcoBreaker').value) || '';
                systemData.kepco.status = 'complete';

                // KEPCO 정보 구성
                let kepcoInfoLines = [];
                if (systemData.kepco.voltage && systemData.kepco.voltage !== '') {
                    kepcoInfoLines.push(systemData.kepco.voltage);
                }
                if (systemData.kepco.contractPower && systemData.kepco.contractPower !== '') {
                    kepcoInfoLines.push(`${systemData.kepco.contractPower}kW`);
                }
                if (systemData.kepco.breaker && systemData.kepco.breaker !== '') {
                    kepcoInfoLines.push(`${systemData.kepco.breaker}A`);
                }

                // 노드 업데이트
                const node = document.getElementById('kepco');
                node.querySelector('.node-info').textContent = kepcoInfoLines.length > 0 ? kepcoInfoLines.join(' / ') : '-';
                node.querySelector('.node-status').textContent = '✓';
                node.querySelector('.node-status').className = 'node-status';
                
            } else if (nodeId.startsWith('tr')) {
                const tr = systemData.transformers[nodeId];
                tr.title = document.getElementById('editTrName').value;
                tr.capacity = parseInt(document.getElementById('editTrCapacity').value) || '';
                tr.voltage = document.getElementById('editTrVoltage').value;
                tr.breaker = parseInt(document.getElementById('editTrBreaker').value) || '';
                tr.status = 'complete';

                // 변압기 정보 구성
                let trInfoLines = [];
                if (tr.capacity && tr.capacity !== '') {
                    trInfoLines.push(`${tr.capacity}kVA`);
                }
                if (tr.voltage && tr.voltage !== '') {
                    trInfoLines.push(`${tr.voltage}V`);
                }
                if (tr.breaker && tr.breaker !== '') {
                    trInfoLines.push(`${tr.breaker}A`);
                }

                // 노드 업데이트
                const node = document.getElementById(nodeId);
                node.querySelector('.node-title').textContent = tr.title;
                node.querySelector('.node-info').textContent = trInfoLines.length > 0 ? trInfoLines.join(' / ') : '-';
                node.querySelector('.node-status').textContent = '✓';
                node.querySelector('.node-status').className = 'node-status';

            } else if (nodeId.startsWith('mcc')) {
                const mcc = systemData.panels[nodeId];
                mcc.title = document.getElementById('editMccName').value;
                mcc.mainBreaker = parseInt(document.getElementById('editMccBreaker').value) || '';
                mcc.status = 'complete';

                // 노드 업데이트
                const node = document.getElementById(nodeId);
                node.querySelector('.node-title').textContent = mcc.title;
                node.querySelector('.node-info').textContent = mcc.mainBreaker && mcc.mainBreaker !== '' ? `${mcc.mainBreaker}A` : '-';
                node.querySelector('.node-status').textContent = '✓';
                node.querySelector('.node-status').className = 'node-status';

            } else if (nodeId.startsWith('load')) {
                const load = systemData.loads[nodeId];
                load.title = document.getElementById('editLoadName').value;
                load.type = document.getElementById('editLoadType').value;
                load.loadRate = parseInt(document.getElementById('editLoadRate').value) || '';
                load.notes = document.getElementById('editLoadNotes').value;
                load.status = 'complete';

                // 부하 정보 구성
                let loadInfoLines = [];
                if (load.type && load.type !== '') {
                    loadInfoLines.push(load.type);
                }
                if (load.loadRate && load.loadRate !== '') {
                    loadInfoLines.push(`${load.loadRate}%`);
                }

                // 노드 업데이트
                const node = document.getElementById(nodeId);
                node.querySelector('.node-title').textContent = load.title;
                node.querySelector('.node-info').textContent = loadInfoLines.length > 0 ? loadInfoLines.join(' / ') : '-';
                node.querySelector('.node-status').textContent = '✓';
                node.querySelector('.node-status').className = 'node-status';
            }
            
            closeDetail();
            updateStatistics();
        }

        // 상세 패널 닫기
        function closeDetail() {
            document.getElementById('detailPanel').classList.remove('open');
            document.querySelectorAll('.tree-node').forEach(node => {
                node.classList.remove('selected');
            });
            selectedNode = null;

            // 패널 닫힘 후 연결선 다시 그리기
            setTimeout(() => {
                redrawConnections();
            }, 300); // 패널 닫힘 애니메이션 대기
        }

        // 모달 닫기
        function closeModal() {
            document.getElementById('addModal').classList.remove('show');
            currentModalType = null;
        }

        // 통계 업데이트
        function updateStatistics() {
            // 통계 카드와 진행률 바가 삭제되어 더 이상 업데이트할 요소가 없음
            // 이 함수는 호환성을 위해 유지하되 내용은 비움
        }

        // 진행률 업데이트
        function updateProgress() {
            let completed = 0;
            let total = 1; // kepco
            
            if (systemData.kepco.status === 'complete') completed++;
            
            Object.values(systemData.transformers).forEach(tr => {
                total++;
                if (tr.status === 'complete') completed++;
            });
            
            Object.values(systemData.panels).forEach(panel => {
                total++;
                if (panel.status === 'complete') completed++;
            });
            
            Object.values(systemData.loads).forEach(load => {
                total++;
                if (load.status === 'complete') completed++;
            });
            
            // 진행률 바가 삭제되어 더 이상 업데이트할 요소가 없음
        }

        // 자동 스케일 조정 함수
        function autoScaleTree() {
            const diagram = document.getElementById('treeDiagram');
            const container = diagram.parentElement;

            // 실제 콘텐츠 너비 계산
            const contentWidth = diagram.scrollWidth;
            const containerWidth = container.clientWidth - 40; // 패딩 고려

            if (contentWidth > containerWidth) {
                // 화면에 맞춰 자동 스케일 적용
                const scale = Math.max(0.3, containerWidth / contentWidth);
                diagram.style.transform = `scale(${scale})`;

                // 컨테이너 크기를 스케일된 콘텐츠에 맞춰 조정
                const scaledWidth = contentWidth * scale;
                const scaledHeight = diagram.offsetHeight * scale;

                // 컨테이너의 실제 공간을 스케일된 크기에 맞춤
                container.style.height = `${scaledHeight + 60}px`; // 패딩 고려
                diagram.style.marginBottom = '0px';

                // 스케일 변경 후 연결선 다시 그리기
                setTimeout(() => redrawConnections(), 100);
            } else {
                diagram.style.transform = 'scale(1)';
                diagram.style.marginBottom = '0px';
                container.style.height = 'auto';

                // 스케일 리셋 후 연결선 다시 그리기
                setTimeout(() => redrawConnections(), 100);
            }
        }

        // 연결선 다시 그리기
        function redrawConnections() {
            const svg = document.getElementById('treeSvg');
            svg.innerHTML = '';
            
            // 한전 -> 변압기
            Object.keys(systemData.transformers).forEach(trId => {
                drawLine(svg, 'kepco', trId);
            });
            
            // 변압기 -> 분전반
            Object.keys(systemData.connections.transformerToPanels).forEach(trId => {
                const panels = systemData.connections.transformerToPanels[trId];
                panels.forEach(panelId => {
                    drawLine(svg, trId, panelId);
                });
            });
            
            // 분전반 -> 부하
            Object.keys(systemData.connections.panelToLoads).forEach(panelId => {
                const loads = systemData.connections.panelToLoads[panelId];
                loads.forEach(loadId => {
                    drawLine(svg, panelId, loadId);
                });
            });
        }

        // 선 그리기
        function drawLine(svg, fromId, toId) {
            const from = document.getElementById(fromId);
            const to = document.getElementById(toId);

            if (!from || !to) return;

            // 다이어그램과 SVG의 현재 transform 상태 고려
            const diagram = document.getElementById('treeDiagram');
            const currentTransform = diagram.style.transform;

            // 스케일 값 추출 (기본값 1)
            let scale = 1;
            if (currentTransform && currentTransform.includes('scale')) {
                const scaleMatch = currentTransform.match(/scale\(([\d.]+)\)/);
                if (scaleMatch) {
                    scale = parseFloat(scaleMatch[1]);
                }
            }

            // 요소의 상대적 위치 계산 (다이어그램 기준)
            const diagramRect = diagram.getBoundingClientRect();
            const fromRect = from.getBoundingClientRect();
            const toRect = to.getBoundingClientRect();

            // 다이어그램 내부 좌표로 변환
            const x1 = (fromRect.left - diagramRect.left) / scale + fromRect.width / (2 * scale);
            const y1 = (fromRect.bottom - diagramRect.top) / scale;
            const x2 = (toRect.left - diagramRect.left) / scale + toRect.width / (2 * scale);
            const y2 = (toRect.top - diagramRect.top) / scale;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${x1} ${y1} C ${x1} ${y1 + 30}, ${x2} ${y2 - 30}, ${x2} ${y2}`;
            path.setAttribute('d', d);
            path.setAttribute('class', 'tree-path');
            path.setAttribute('id', `path-${fromId}-${toId}`);

            svg.appendChild(path);
        }

        // 데이터 저장
        function saveData() {
            localStorage.setItem('reactorSurveyData', JSON.stringify(systemData));
            alert('✅ 데이터가 저장되었습니다.');
        }

        // 데이터 내보내기
        function exportData() {
            const dataStr = JSON.stringify(systemData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;

            // 업체명과 조사날짜로 파일명 생성
            const companyName = systemData.companyInfo.name || '현장조사';
            const dateStr = systemData.companyInfo.surveyDate || new Date().toISOString().slice(0,10);
            link.download = `${companyName}_조사데이터_${dateStr}.json`;
            link.click();
        }

        // 데이터 가져오기
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);

                        // systemData 업데이트
                        systemData = importedData;

                        // 카운터 변수들도 업데이트 (있는 경우)
                        if (importedData.transformerCounter !== undefined) {
                            transformerCounter = importedData.transformerCounter;
                        }
                        if (importedData.mccCounter !== undefined) {
                            mccCounter = importedData.mccCounter;
                        }
                        if (importedData.loadCounter !== undefined) {
                            loadCounter = importedData.loadCounter;
                        }

                        // UI 전체 업데이트
                        updateStatistics();
                        updateProgress();

                        // 트리 구조 재구성
                        rebuildTreeFromData();

                        // 연결선 다시 그리기
                        setTimeout(() => {
                            redrawConnections();
                        }, 100);

                        // 모든 노드의 사진 표시 업데이트 (통합된 images 구조 사용)
                        if (systemData.images) {
                            Object.keys(systemData.images).forEach(nodeId => {
                                if (systemData.images[nodeId] && systemData.images[nodeId].length > 0) {
                                    updatePhotoDisplay(nodeId);
                                }
                            });
                        }

                        alert('✅ JSON 데이터가 성공적으로 불러와졌습니다!');

                    } catch (err) {
                        console.error('JSON 파싱 오류:', err);
                        alert('❌ JSON 파일을 읽을 수 없습니다. 올바른 형식인지 확인해주세요.');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // 자동 계산
        function autoCalculate() {
            // 변압기 부하 계산 (부하율 계산 제거됨)
            Object.keys(systemData.transformers).forEach(trId => {
                const connectedPanels = systemData.connections.transformerToPanels[trId] || [];
                let totalLoad = 0;

                connectedPanels.forEach(panelId => {
                    const connectedLoads = systemData.connections.panelToLoads[panelId] || [];
                    connectedLoads.forEach(loadId => {
                        const load = systemData.loads[loadId];
                        if (load) {
                            totalLoad += load.capacity * load.quantity * (load.loadRate / 100);
                        }
                    });
                });

                // 부하율 자동 계산 제거됨
            });
            
            updateStatistics();
            alert('✅ 자동 계산이 완료되었습니다.');
        }

        // 초기화
        function resetAll() {
            if (confirm('모든 데이터를 초기화하시겠습니까?')) {
                systemData = {
                    kepco: {
                        voltage: '22.9kV',
                        contractPower: '',
                        breaker: '',
                        receptionType: '',
                        vcb: '',
                        status: 'empty'
                    },
                    transformers: {},
                    panels: {},
                    loads: {},
                    images: {},
                    connections: {
                        transformerToPanels: {},
                        panelToLoads: {}
                    }
                };
                
                transformerCounter = 0;
                mccCounter = 0;
                loadCounter = 0;
                
                location.reload();
            }
        }

        // 썸네일 생성 함수
        function createThumbnail(file, callback) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // 썸네일 크기 설정 (400x300 최대, 비율 유지)
                    const MAX_WIDTH = 400;
                    const MAX_HEIGHT = 300;

                    let width = img.width;
                    let height = img.height;

                    // 비율 유지하며 리사이즈
                    if (width > height) {
                        if (width > MAX_WIDTH) {
                            height = (MAX_WIDTH / width) * height;
                            width = MAX_WIDTH;
                        }
                    } else {
                        if (height > MAX_HEIGHT) {
                            width = (MAX_HEIGHT / height) * width;
                            height = MAX_HEIGHT;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    // JPEG 품질 60% (썸네일용)
                    const thumbnail = canvas.toDataURL('image/jpeg', 0.6);
                    callback(thumbnail);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 사진 촬영 기능 (썸네일 방식)
        function addPhoto(nodeId, category = 'general') {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.capture = 'environment';
            input.style.display = 'none';

            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    // 썸네일 생성
                    createThumbnail(file, (thumbnailData) => {
                        // 현재 시간을 YYYYMMDD_HHMMSS 형식으로
                        const now = new Date();
                        const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);

                        // 이미지 데이터를 systemData에 저장 (썸네일 + 메타데이터)
                        if (!systemData.images[nodeId]) {
                            systemData.images[nodeId] = [];
                        }

                        // 카테고리별 라벨 설정
                        const categoryLabels = {
                            'general': '현장 사진',
                            'breaker-label': '차단기 라벨',
                            'panel-config': '분전반 구성',
                            'transformer-config': '변압기 구성'
                        };

                        systemData.images[nodeId].push({
                            thumbnail: thumbnailData,           // 썸네일 (30-50KB)
                            originalName: file.name,            // 원본 파일명
                            timestamp: now.toISOString(),       // ISO 형식 시간
                            displayTime: now.toLocaleString(),  // 화면 표시용 시간
                            size: Math.round(file.size / 1024) + 'KB', // 원본 크기
                            nodeId: nodeId,                     // 노드 ID 참조
                            category: category,                 // 사진 카테고리
                            categoryLabel: categoryLabels[category] || '현장 사진'  // 카테고리 라벨
                        });

                        alert(`📸 ${categoryLabels[category] || '사진'}이 추가되었습니다!\n원본: ${file.name} (${Math.round(file.size/1024)}KB)\n썸네일로 저장됨`);
                        updatePhotoDisplay(nodeId);
                        updateDetailPhotoDisplay(nodeId);
                        redrawConnections(); // 연결선 다시 그리기
                    });
                }
            };

            document.body.appendChild(input);
            input.click();
            document.body.removeChild(input);
        }

        // 사진 표시 업데이트 (트리 노드용)
        function updatePhotoDisplay(nodeId) {
            const photoContainer = document.getElementById(`photos-${nodeId}`);
            if (!photoContainer) return;

            photoContainer.innerHTML = '';
            const images = systemData.images[nodeId] || [];

            images.forEach((img, index) => {
                const imgElement = document.createElement('img');
                imgElement.src = img.thumbnail || img.data; // 썸네일 우선, 기존 data 호환
                imgElement.style.cssText = 'width: 40px; height: 40px; object-fit: cover; margin: 2px; border-radius: 4px; cursor: pointer;';
                imgElement.title = `${img.originalName || 'photo'} (${img.displayTime || ''})`;
                imgElement.onclick = () => viewFullImage(img.thumbnail || img.data);
                photoContainer.appendChild(imgElement);
            });

            // DOM 변경 후 연결선 다시 그리기
            setTimeout(() => {
                redrawConnections();
            }, 50);
        }

        // 상세 패널에서 사진 표시 업데이트
        function updateDetailPhotoDisplay(nodeId) {
            const detailPhotoContainer = document.getElementById(`detail-photos-${nodeId}`);
            if (!detailPhotoContainer) return;

            detailPhotoContainer.innerHTML = '';
            const images = systemData.images[nodeId] || [];

            if (images.length === 0) {
                detailPhotoContainer.innerHTML = '<div style="color: #666; font-size: 12px; padding: 10px;">촬영된 사진이 없습니다.</div>';
                return;
            }

            images.forEach((img, index) => {
                const imgWrapper = document.createElement('div');
                imgWrapper.style.cssText = 'display: inline-block; position: relative; margin: 4px; background: #f8f8f8; border-radius: 8px; padding: 4px;';

                const imgElement = document.createElement('img');
                imgElement.src = img.thumbnail || img.data; // 썸네일 우선, 기존 data 호환
                imgElement.style.cssText = 'width: 80px; height: 80px; object-fit: cover; border-radius: 6px; cursor: pointer; border: 2px solid #ddd;';
                imgElement.title = `원본: ${img.originalName || 'photo'}\n크기: ${img.size || 'unknown'}\n촬영: ${img.displayTime || ''}`;
                imgElement.onclick = () => viewFullImage(img.thumbnail || img.data);

                // 사진 정보 표시
                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = 'font-size: 10px; color: #666; text-align: center; margin-top: 2px; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
                infoDiv.textContent = img.categoryLabel || img.originalName || `Photo ${index + 1}`;
                infoDiv.title = `분류: ${img.categoryLabel || '현장 사진'}\n원본: ${img.originalName || 'photo'}\n크기: ${img.size || 'unknown'}\n촬영: ${img.displayTime || ''}`;

                // 삭제 버튼
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '×';
                deleteBtn.style.cssText = `
                    position: absolute; top: -2px; right: -2px; width: 18px; height: 18px;
                    border-radius: 50%; background: #f44336; color: white; border: none;
                    cursor: pointer; font-size: 12px; display: flex; align-items: center;
                    justify-content: center; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                `;
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deletePhoto(nodeId, index);
                };

                imgWrapper.appendChild(imgElement);
                imgWrapper.appendChild(infoDiv);
                imgWrapper.appendChild(deleteBtn);
                detailPhotoContainer.appendChild(imgWrapper);
            });

            // DOM 변경 후 연결선 다시 그리기
            setTimeout(() => {
                redrawConnections();
            }, 50);
        }

        // 사진 삭제
        function deletePhoto(nodeId, index) {
            if (confirm('이 사진을 삭제하시겠습니까?')) {
                systemData.images[nodeId].splice(index, 1);
                updatePhotoDisplay(nodeId);
                updateDetailPhotoDisplay(nodeId);
                redrawConnections(); // 연결선 다시 그리기
                alert('📸 사진이 삭제되었습니다.');
            }
        }

        // 전체 이미지 보기
        function viewFullImage(imageSrc) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 10000; display: flex;
                justify-content: center; align-items: center; cursor: pointer;
            `;

            const img = document.createElement('img');
            img.src = imageSrc;
            img.style.cssText = 'max-width: 90%; max-height: 90%; object-fit: contain;';

            modal.appendChild(img);
            modal.onclick = () => document.body.removeChild(modal);
            document.body.appendChild(modal);
        }


        // 저장된 데이터로부터 트리 재구성

        // 업체정보 모달 열기
        function openCompanyInfo() {
            const modal = document.getElementById('companyInfoModal');

            // 기존 데이터 로드
            if (systemData.companyInfo) {
                document.getElementById('companyName').value = systemData.companyInfo.name || '';
                document.getElementById('companyAddress').value = systemData.companyInfo.address || '';
                document.getElementById('companyContact').value = systemData.companyInfo.contact || '';
                document.getElementById('companyManager').value = systemData.companyInfo.manager || '';
                document.getElementById('surveyDate').value = systemData.companyInfo.surveyDate || '';
                document.getElementById('companyNotes').value = systemData.companyInfo.notes || '';
            }

            modal.style.display = 'block';
        }

        // 업체정보 모달 닫기
        function closeCompanyInfo() {
            document.getElementById('companyInfoModal').style.display = 'none';
        }

        // 업체정보 저장
        function saveCompanyInfo() {
            systemData.companyInfo = {
                name: document.getElementById('companyName').value,
                address: document.getElementById('companyAddress').value,
                contact: document.getElementById('companyContact').value,
                manager: document.getElementById('companyManager').value,
                surveyDate: document.getElementById('surveyDate').value,
                notes: document.getElementById('companyNotes').value
            };

            alert('✅ 업체 정보가 저장되었습니다!');
            closeCompanyInfo();

            // 통계 업데이트
            updateStatistics();
        }

        function rebuildTreeFromData() {
            // 트리 컨테이너 초기화
            const treeView = document.getElementById('treeView');
            if (!treeView) return;

            // 기존 노드들 제거 (KEPCO와 추가 버튼은 유지)
            const existingNodes = treeView.querySelectorAll('.tree-node:not(#kepco):not(.add-node)');
            existingNodes.forEach(node => node.remove());

            // KEPCO 수전 정보 업데이트
            let kepcoNode = document.getElementById('kepco');
            if (kepcoNode && systemData.kepco) {
                // KEPCO 정보 구성 (최신 형식)
                let kepcoInfoLines = [];
                if (systemData.kepco.voltage && systemData.kepco.voltage !== '') {
                    kepcoInfoLines.push(systemData.kepco.voltage);
                }
                if (systemData.kepco.contractPower && systemData.kepco.contractPower !== '') {
                    kepcoInfoLines.push(`${systemData.kepco.contractPower}kW`);
                }
                if (systemData.kepco.breaker && systemData.kepco.breaker !== '') {
                    kepcoInfoLines.push(`${systemData.kepco.breaker}A`);
                }

                // 기존 KEPCO 노드 업데이트
                const nodeInfo = kepcoNode.querySelector('.node-info');
                const nodeStatus = kepcoNode.querySelector('.node-status');

                if (nodeInfo) {
                    nodeInfo.textContent = kepcoInfoLines.length > 0 ? kepcoInfoLines.join(' / ') : '-';
                }
                if (nodeStatus) {
                    nodeStatus.className = `node-status ${systemData.kepco.status || 'empty'}`;
                    nodeStatus.textContent = systemData.kepco.status === 'completed' ? '완료' :
                                            systemData.kepco.status === 'incomplete' ? '진행중' : '-';
                }
            }

            // 변압기 노드들 재생성
            Object.values(systemData.transformers || {}).forEach(transformer => {
                addTransformerNode(transformer.id);
            });

            // MCC 노드들 재생성
            Object.values(systemData.panels || {}).forEach(panel => {
                addMCCNode(panel.id);
            });

            // 부하 노드들 재생성
            Object.values(systemData.loads || {}).forEach(load => {
                addLoadNode(load.id);
            });

            // 모든 노드의 사진 표시 업데이트
            setTimeout(() => {
                if (systemData.images) {
                    Object.keys(systemData.images).forEach(nodeId => {
                        if (systemData.images[nodeId] && systemData.images[nodeId].length > 0) {
                            updatePhotoDisplay(nodeId);
                        }
                    });
                }
            }, 50);

            // 통계 업데이트
            updateStatistics();

            // 업체 정보가 있으면 제목 업데이트
            if (systemData.companyInfo && systemData.companyInfo.name) {
                const headerH1 = document.querySelector('.header h1');
                if (headerH1) {
                    headerH1.textContent = `현장조사 결과 - [${systemData.companyInfo.name}]`;
                }
            }
        }

        // 상태 텍스트 반환 함수
        function getStatusText(status) {
            switch (status) {
                case 'completed': return '완료';
                case 'incomplete': return '진행중';
                default: return '미완료';
            }
        }

        // 보고서 생성
        function generateReport() {
            let report = '=== 리액터 설치 현장조사 보고서 ===\n\n';
            report += `조사일: ${new Date().toLocaleDateString()}\n\n`;

            report += '1. 수전설비\n';
            report += `   - 수전전압: ${systemData.kepco.voltage}\n`;
            report += `   - 계약전력: ${systemData.kepco.contractPower}kW\n`;
            report += `   - 수전방식: ${systemData.kepco.receptionType}\n\n`;

            report += '2. 변압기 현황\n';
            Object.values(systemData.transformers).forEach(tr => {
                report += `   - ${tr.title}: ${tr.capacity}kVA (전압: ${tr.voltage || '380/220'}V)\n`;
            });

            report += '\n3. 권장 리액터 용량\n';
            report += `   - ${document.getElementById('recommendedReactor').textContent}kVar\n`;

            alert(report);
        }

        // 햄버거 메뉴 토글 함수
        function toggleMobileMenu() {
            const hamburgerBtn = document.querySelector('.hamburger-btn');
            const dropdown = document.getElementById('mobileMenuDropdown');

            hamburgerBtn.classList.toggle('active');
            dropdown.classList.toggle('active');
        }

        // 모바일 메뉴 닫기 함수
        function closeMobileMenu() {
            const hamburgerBtn = document.querySelector('.hamburger-btn');
            const dropdown = document.getElementById('mobileMenuDropdown');

            hamburgerBtn.classList.remove('active');
            dropdown.classList.remove('active');
        }

        // 외부 클릭 시 메뉴 닫기
        document.addEventListener('click', function(event) {
            const mobileMenuContainer = document.querySelector('.mobile-menu-container');
            const dropdown = document.getElementById('mobileMenuDropdown');

            if (mobileMenuContainer && !mobileMenuContainer.contains(event.target) && dropdown && dropdown.classList.contains('active')) {
                closeMobileMenu();
            }
        });

        // 사진 대조표 생성 함수
        function generatePhotoIndex() {
            const allPhotos = [];

            // 각 노드의 사진 수집
            ['kepco', 'transformers', 'panels', 'loads'].forEach(nodeType => {
                const nodes = nodeType === 'kepco' ? [systemData.kepco] : Object.values(systemData[nodeType]);

                nodes.forEach(node => {
                    if (node.images && node.images.length > 0) {
                        node.images.forEach((photo, index) => {
                            allPhotos.push({
                                nodeId: node.id || 'kepco',
                                nodeTitle: node.title || node.id || 'KEPCO 수전',
                                photoIndex: index + 1,
                                originalName: photo.originalName || '사진' + (index + 1),
                                timestamp: photo.timestamp || new Date().toISOString(),
                                displayTime: photo.displayTime || new Date(photo.timestamp).toLocaleString(),
                                size: photo.size || 'Unknown'
                            });
                        });
                    }
                });
            });

            if (allPhotos.length === 0) {
                alert('저장된 사진이 없습니다.');
                return;
            }

            // CSV 생성
            let csvContent = '번호,노드,사진번호,원본파일명,촬영시간,파일크기\n';
            allPhotos.forEach((photo, index) => {
                csvContent += `${index + 1},${photo.nodeTitle},${photo.photoIndex},${photo.originalName},${photo.displayTime},${photo.size}\n`;
            });

            // CSV 다운로드
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '사진대조표.csv';
            a.click();
            URL.revokeObjectURL(url);

            // 미리보기 표시
            showPhotoIndexPreview(allPhotos);
        }

        // 사진 대조표 미리보기 표시
        function showPhotoIndexPreview(photos) {
            let previewHtml = '<div style="max-height: 500px; overflow-y: auto; margin-top: 20px;">';
            previewHtml += '<h3>📋 사진 대조표 미리보기</h3>';
            previewHtml += '<table style="width: 100%; border-collapse: collapse; font-size: 12px;">';
            previewHtml += '<tr style="background: #f0f0f0; font-weight: bold;">';
            previewHtml += '<th style="border: 1px solid #ddd; padding: 8px;">번호</th>';
            previewHtml += '<th style="border: 1px solid #ddd; padding: 8px;">노드</th>';
            previewHtml += '<th style="border: 1px solid #ddd; padding: 8px;">사진번호</th>';
            previewHtml += '<th style="border: 1px solid #ddd; padding: 8px;">원본파일명</th>';
            previewHtml += '<th style="border: 1px solid #ddd; padding: 8px;">촬영시간</th>';
            previewHtml += '<th style="border: 1px solid #ddd; padding: 8px;">파일크기</th>';
            previewHtml += '</tr>';

            photos.forEach((photo, index) => {
                previewHtml += '<tr>';
                previewHtml += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${index + 1}</td>`;
                previewHtml += `<td style="border: 1px solid #ddd; padding: 6px;">${photo.nodeTitle}</td>`;
                previewHtml += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${photo.photoIndex}</td>`;
                previewHtml += `<td style="border: 1px solid #ddd; padding: 6px;">${photo.originalName}</td>`;
                previewHtml += `<td style="border: 1px solid #ddd; padding: 6px;">${photo.displayTime}</td>`;
                previewHtml += `<td style="border: 1px solid #ddd; padding: 6px;">${photo.size}</td>`;
                previewHtml += '</tr>';
            });

            previewHtml += '</table>';
            previewHtml += '<p style="margin-top: 15px; color: #666; font-size: 11px;">';
            previewHtml += '💡 이 대조표를 사용해 썸네일과 원본 사진을 매칭하세요.<br>';
            previewHtml += '📂 원본 사진들은 별도로 보관하고 필요시 대조표를 참고하여 찾으세요.';
            previewHtml += '</p>';
            previewHtml += '</div>';

            // 새 창에서 미리보기 표시
            const newWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes');
            const htmlContent = '<html>' +
                '<head>' +
                '<title>사진 대조표 미리보기</title>' +
                '<meta charset="UTF-8">' +
                '</head>' +
                '<body style="font-family: Arial, sans-serif; margin: 20px;">' +
                previewHtml +
                '<div style="margin-top: 20px; text-align: center;">' +
                '<button onclick="window.close()" style="padding: 10px 20px; font-size: 14px;">창 닫기</button>' +
                '</div>' +
                '</body>' +
                '</html>';
            newWindow.document.write(htmlContent);
            newWindow.document.close();

            alert('✅ 사진 대조표 CSV 파일이 다운로드되었고, 미리보기 창이 열렸습니다!');
        }

        // 초기화
        window.addEventListener('load', () => {
            updateStatistics();

            // SVG 크기 설정
            setTimeout(() => {
                const diagram = document.getElementById('treeDiagram');
                const svg = document.getElementById('treeSvg');
                if (diagram && svg) {
                    svg.setAttribute('width', diagram.offsetWidth);
                    svg.setAttribute('height', diagram.offsetHeight);
                }
            }, 100);
        });

        // 창 크기 변경시 연결선 다시 그리기 및 스케일 조정
        window.addEventListener('resize', () => {
            if (typeof redrawConnections === 'function') {
                redrawConnections();
            }
            // 자동 스케일 조정
            setTimeout(() => {
                autoScaleTree();
            }, 100);
        });

        // 키보드 단축키
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDetail();
                if (typeof closeModal === 'function') closeModal();
                if (typeof cancelDelete === 'function') cancelDelete();
                if (typeof closeFloorPlan === 'function') closeFloorPlan();
            } else if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (typeof saveData === 'function') saveData();
            }
        });

        // ========== 평면도 관련 함수들 ==========

        let floorPlanCanvas = null;
        let floorPlanCtx = null;
        let selectedFloorPlanItem = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        // 평면도 모달 열기
        function openFloorPlan() {
            document.getElementById('floorPlanModal').classList.add('show');
            setTimeout(() => {
                initFloorPlanCanvas();
                loadFloorPlanData();
                updateFloorPlan();
            }, 100);
        }

        // 평면도 모달 닫기
        function closeFloorPlan() {
            document.getElementById('floorPlanModal').classList.remove('show');
        }

        // Canvas 초기화
        function initFloorPlanCanvas() {
            floorPlanCanvas = document.getElementById('floorPlanCanvas');
            floorPlanCtx = floorPlanCanvas.getContext('2d');

            // 고해상도 디스플레이 지원
            const rect = floorPlanCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            floorPlanCanvas.width = rect.width * dpr;
            floorPlanCanvas.height = rect.height * dpr;
            floorPlanCtx.scale(dpr, dpr);

            // 마우스 이벤트 추가
            floorPlanCanvas.addEventListener('mousedown', onFloorPlanMouseDown);
            floorPlanCanvas.addEventListener('mousemove', onFloorPlanMouseMove);
            floorPlanCanvas.addEventListener('mouseup', onFloorPlanMouseUp);
            floorPlanCanvas.addEventListener('wheel', onFloorPlanWheel);

            // 터치 이벤트 추가 (모바일 지원)
            floorPlanCanvas.addEventListener('touchstart', onFloorPlanTouchStart);
            floorPlanCanvas.addEventListener('touchmove', onFloorPlanTouchMove);
            floorPlanCanvas.addEventListener('touchend', onFloorPlanTouchEnd);

            // 터치 시 스크롤 방지
            floorPlanCanvas.addEventListener('touchstart', (e) => e.preventDefault());
            floorPlanCanvas.addEventListener('touchmove', (e) => e.preventDefault());
        }

        // 평면도 데이터 로드
        function loadFloorPlanData() {
            const fp = systemData.floorPlan;
            if (fp.enabled) {
                document.getElementById('roomWidth').value = fp.roomDimensions.width || '';
                document.getElementById('roomLength').value = fp.roomDimensions.length || '';
                // roomHeight 필드 제거됨

                updateDoorsList();
                updateExistingEquipmentList();
                updateReactorProductsList();
            }
        }

        // 평면도 업데이트 및 그리기
        function updateFloorPlan() {
            if (!floorPlanCtx) return;

            const canvas = floorPlanCanvas;
            const ctx = floorPlanCtx;

            // 캔버스 클리어
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 데이터 업데이트
            const width = parseInt(document.getElementById('roomWidth').value) || 8000;
            const length = parseInt(document.getElementById('roomLength').value) || 6000;
            const height = 3000;  // 기본값 고정 (입력 필드 제거됨)

            systemData.floorPlan.roomDimensions = { width, length, height };

            // 축척 계산 (초기값 또는 자동 맞춤, offset 고려)
            if (!systemData.floorPlan.scale || systemData.floorPlan.scale === 0) {
                const canvasWidth = canvas.getBoundingClientRect().width - 120;  // offsetX 여백 + 패딩 (100→120)
                const canvasHeight = canvas.getBoundingClientRect().height - 80;  // offsetY 여백 + 패딩 (60→80)
                const scaleX = canvasWidth / width;
                const scaleY = canvasHeight / length;
                systemData.floorPlan.scale = Math.min(scaleX, scaleY) * 0.95;  // 95%로 축소하여 여유 확보
            }

            const scale = systemData.floorPlan.scale;
            const offsetX = 50;
            const offsetY = 30;

            // 방이 정의된 경우
            if (width > 0 && length > 0) {
                // 1. 방 외곽선 및 배경 그리기 (가장 먼저)
                drawRoom(ctx, width, length, scale, offsetX, offsetY);

                // 2. 격자 그리기 (방 위에 표시)
                drawGrid(ctx, width, length, scale, offsetX, offsetY);

                // 3. 출입구 그리기
                systemData.floorPlan.doors.forEach(door => {
                    drawDoor(ctx, door, scale, offsetX, offsetY);
                });

                // 4. 기존 설비 그리기
                systemData.floorPlan.existingEquipment.forEach(equipment => {
                    drawExistingEquipment(ctx, equipment, scale, offsetX, offsetY);
                });

                // 5. 리액터 제품 그리기 (가장 위에)
                systemData.floorPlan.reactorProducts.forEach(product => {
                    drawReactorProduct(ctx, product, scale, offsetX, offsetY);
                });
            } else {
                // 방이 정의되지 않은 경우 기본 격자만 표시
                drawBaseGrid(ctx, canvasWidth, canvasHeight, offsetX, offsetY);
            }

            // 축척 정보 업데이트
            updateScaleDisplay(scale);
        }

        // 기본 격자 그리기 (캔버스 전체에 표시)
        function drawBaseGrid(ctx, canvasWidth, canvasHeight, offsetX, offsetY) {
            const smallSpacing = 10; // 작은 격자 (10픽셀)
            const mediumSpacing = 50; // 중간 격자 (50픽셀)
            const largeSpacing = 100; // 큰 격자 (100픽셀)

            // 1단계: 미세격자 (10픽셀 간격) - 매우 옅게
            ctx.strokeStyle = 'rgba(240, 240, 240, 0.3)';
            ctx.lineWidth = 0.25;
            ctx.setLineDash([]);

            // 세로선
            for (let x = offsetX; x <= canvasWidth + offsetX; x += smallSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, canvasHeight + offsetY);
                ctx.stroke();
            }

            // 가로선
            for (let y = offsetY; y <= canvasHeight + offsetY; y += smallSpacing) {
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(canvasWidth + offsetX, y);
                ctx.stroke();
            }

            // 2단계: 중간격자 (50픽셀 간격)
            ctx.strokeStyle = 'rgba(220, 220, 220, 0.5)';
            ctx.lineWidth = 0.5;

            // 세로선
            for (let x = offsetX; x <= canvasWidth + offsetX; x += mediumSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, canvasHeight + offsetY);
                ctx.stroke();
            }

            // 가로선
            for (let y = offsetY; y <= canvasHeight + offsetY; y += mediumSpacing) {
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(canvasWidth + offsetX, y);
                ctx.stroke();
            }

            // 3단계: 주격자 (100픽셀 간격)
            ctx.strokeStyle = 'rgba(180, 180, 180, 0.7)';
            ctx.lineWidth = 0.8;

            // 세로선
            for (let x = offsetX; x <= canvasWidth + offsetX; x += largeSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, canvasHeight + offsetY);
                ctx.stroke();
            }

            // 가로선
            for (let y = offsetY; y <= canvasHeight + offsetY; y += largeSpacing) {
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(canvasWidth + offsetX, y);
                ctx.stroke();
            }

            // 격자점 표시 (중간격자 교차점에만)
            ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
            for (let x = offsetX; x <= canvasWidth + offsetX; x += mediumSpacing) {
                for (let y = offsetY; y <= canvasHeight + offsetY; y += mediumSpacing) {
                    // 주격자 교차점은 더 큰 점
                    if ((x - offsetX) % largeSpacing === 0 && (y - offsetY) % largeSpacing === 0) {
                        ctx.fillStyle = 'rgba(150, 150, 150, 0.8)';
                        ctx.fillRect(x - 1, y - 1, 2, 2);
                    } else {
                        ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
                        ctx.fillRect(x - 0.5, y - 0.5, 1, 1);
                    }
                }
            }

            ctx.setLineDash([]);
        }

        // 격자 그리기 (100mm 기반)
        function drawGrid(ctx, roomWidth, roomLength, scale, offsetX, offsetY) {
            const gridSize = systemData.floorPlan.gridSize; // 100mm

            // 1단계: 기본 격자 (100mm 간격)
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.8)';  // 더 진하게
            ctx.lineWidth = 0.8;  // 더 두껍게
            ctx.setLineDash([]);

            // 100mm 격자
            const minPixelSpacing = 3; // 최소 픽셀 간격 (5→3으로 축소)
            const actualSpacing = gridSize * scale;

            if (actualSpacing >= minPixelSpacing) {
                // 세로선
                for (let x = 0; x <= roomWidth; x += gridSize) {
                    const canvasX = offsetX + x * scale;
                    ctx.beginPath();
                    ctx.moveTo(canvasX, offsetY);
                    ctx.lineTo(canvasX, offsetY + roomLength * scale);
                    ctx.stroke();
                }

                // 가로선
                for (let y = 0; y <= roomLength; y += gridSize) {
                    const canvasY = offsetY + y * scale;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, canvasY);
                    ctx.lineTo(offsetX + roomWidth * scale, canvasY);
                    ctx.stroke();
                }
            } else {
                // 축척이 너무 작을 때는 500mm 격자만 표시
                const midGridSize = gridSize * 5; // 500mm
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.6)';
                ctx.lineWidth = 1;

                for (let x = 0; x <= roomWidth; x += midGridSize) {
                    const canvasX = offsetX + x * scale;
                    ctx.beginPath();
                    ctx.moveTo(canvasX, offsetY);
                    ctx.lineTo(canvasX, offsetY + roomLength * scale);
                    ctx.stroke();
                }

                for (let y = 0; y <= roomLength; y += midGridSize) {
                    const canvasY = offsetY + y * scale;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, canvasY);
                    ctx.lineTo(offsetX + roomWidth * scale, canvasY);
                    ctx.stroke();
                }
            }

            // 2단계: 500mm 격자 (중간 격자)
            const midGridSize = gridSize * 5; // 500mm
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.9)';  // 더 진하게
            ctx.lineWidth = 1.2;  // 더 두껍게

            // 500mm 격자 세로선
            for (let x = 0; x <= roomWidth; x += midGridSize) {
                const canvasX = offsetX + x * scale;
                ctx.beginPath();
                ctx.moveTo(canvasX, offsetY);
                ctx.lineTo(canvasX, offsetY + roomLength * scale);
                ctx.stroke();
            }

            // 500mm 격자 가로선
            for (let y = 0; y <= roomLength; y += midGridSize) {
                const canvasY = offsetY + y * scale;
                ctx.beginPath();
                ctx.moveTo(offsetX, canvasY);
                ctx.lineTo(offsetX + roomWidth * scale, canvasY);
                ctx.stroke();
            }

            // 3단계: 주격자 (1000mm = 1m 간격)
            const majorGridSize = gridSize * 10; // 1000mm
            ctx.strokeStyle = 'rgba(60, 60, 60, 1.0)';  // 더 진하게
            ctx.lineWidth = 1.5;  // 더 두껍게

            // 1m 격자 세로선
            for (let x = 0; x <= roomWidth; x += majorGridSize) {
                const canvasX = offsetX + x * scale;
                ctx.beginPath();
                ctx.moveTo(canvasX, offsetY);
                ctx.lineTo(canvasX, offsetY + roomLength * scale);
                ctx.stroke();
            }

            // 1m 격자 가로선
            for (let y = 0; y <= roomLength; y += majorGridSize) {
                const canvasY = offsetY + y * scale;
                ctx.beginPath();
                ctx.moveTo(offsetX, canvasY);
                ctx.lineTo(offsetX + roomWidth * scale, canvasY);
                ctx.stroke();
            }

            // 격자점 표시 (축척이 충분히 클 때만 - 500mm 이상 교차점)
            if (actualSpacing >= 10) {  // 충분히 큰 경우만 점 표시
                const midGridSize = gridSize * 5; // 500mm
                for (let x = 0; x <= roomWidth; x += midGridSize) {
                    for (let y = 0; y <= roomLength; y += midGridSize) {
                        const canvasX = offsetX + x * scale;
                        const canvasY = offsetY + y * scale;

                        // 1m 교차점은 더 큰 점
                        if (x % majorGridSize === 0 && y % majorGridSize === 0) {
                            ctx.fillStyle = 'rgba(60, 60, 60, 0.9)';
                            ctx.fillRect(canvasX - 2, canvasY - 2, 4, 4);
                        } else {
                            // 500mm 교차점
                            ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                            ctx.fillRect(canvasX - 1.5, canvasY - 1.5, 3, 3);
                        }
                    }
                }
            }

            ctx.setLineDash([]);
        }

        // 방 외곽선 그리기
        function drawRoom(ctx, width, length, scale, offsetX, offsetY) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.fillStyle = '#ffffff';  // 순백색으로 변경 (격자가 더 잘 보이도록)

            const rect = {
                x: offsetX,
                y: offsetY,
                width: width * scale,
                height: length * scale
            };

            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

            // 치수 표기
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';

            // 가로 치수
            ctx.fillText(`${width}mm`, offsetX + width * scale / 2, offsetY - 5);

            // 세로 치수
            ctx.save();
            ctx.translate(offsetX - 20, offsetY + length * scale / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(`${length}mm`, 0, 0);
            ctx.restore();
        }

        // 출입구 그리기
        function drawDoor(ctx, door, scale, offsetX, offsetY) {
            const isSelected = selectedFloorPlanItem && selectedFloorPlanItem.type === 'door' && selectedFloorPlanItem.item === door;

            const x = offsetX + door.x * scale;
            const y = offsetY + door.y * scale;
            const width = door.width * scale;
            const thickness = 12; // 12픽셀 두께로 고정

            // 출입구 배경 (더 두꺼운 영역)
            ctx.fillStyle = isSelected ? '#81C784' : '#4CAF50';
            ctx.beginPath();

            if (door.orientation === 'horizontal') {
                // 가로형: 두꺼운 수평선
                ctx.rect(x, y - thickness/2, width, thickness);
            } else {
                // 세로형: 두꺼운 수직선
                ctx.rect(x - thickness/2, y, thickness, width);
            }
            ctx.fill();

            // 출입구 테두리
            ctx.strokeStyle = isSelected ? '#66BB6A' : '#388E3C';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 핸들러 (가운데 원형)
            const centerX = door.orientation === 'horizontal' ? x + width/2 : x;
            const centerY = door.orientation === 'horizontal' ? y : y + width/2;

            ctx.fillStyle = isSelected ? '#FFF' : '#2E7D32';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = isSelected ? '#2E7D32' : '#FFF';
            ctx.lineWidth = 1;
            ctx.stroke();

            // 라벨
            ctx.fillStyle = '#2E7D32';
            ctx.font = 'bold 12px Arial';
            const labelX = door.orientation === 'horizontal' ? x + width/2 : x + 15;
            const labelY = door.orientation === 'horizontal' ? y - 8 : y + width/2 + 4;
            ctx.textAlign = 'center';
            ctx.fillText('문', labelX, labelY);
            ctx.textAlign = 'left'; // 기본값으로 복원
        }

        // 기존 설비 그리기
        function drawExistingEquipment(ctx, equipment, scale, offsetX, offsetY) {
            const isSelected = selectedFloorPlanItem && selectedFloorPlanItem.type === 'equipment' && selectedFloorPlanItem.item === equipment;

            ctx.fillStyle = isSelected ? '#FF5722' : '#FF9800';
            ctx.strokeStyle = isSelected ? '#D84315' : '#F57C00';
            ctx.lineWidth = isSelected ? 3 : 2;

            const x = offsetX + equipment.x * scale;
            const y = offsetY + equipment.y * scale;
            const width = equipment.width * scale;
            const height = equipment.length * scale;

            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);

            // 라벨
            ctx.fillStyle = '#fff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(equipment.name, x + width/2, y + height/2 + 3);

            // 선택된 기존설비의 영향 범위 표시
            if (isSelected) {
                ctx.strokeStyle = '#FF5722';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);

                // 접근 영역 표시 (600mm 여유공간)
                const margin = 600 * scale;
                ctx.strokeRect(x - margin, y - margin, width + margin * 2, height + margin * 2);
                ctx.setLineDash([]);
            }
        }

        // 리액터 제품 그리기
        function drawReactorProduct(ctx, product, scale, offsetX, offsetY) {
            const productData = reactorProductDB[product.productId];
            if (!productData) return;

            ctx.fillStyle = selectedFloorPlanItem === product ? '#2196F3' : '#4CAF50';
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 2;

            const x = offsetX + product.x * scale;
            const y = offsetY + product.y * scale;
            const width = productData.dimensions.width * scale;
            const height = productData.dimensions.length * scale;

            // 회전 적용
            ctx.save();
            ctx.translate(x + width/2, y + height/2);
            ctx.rotate(product.rotation * Math.PI / 180);

            ctx.fillRect(-width/2, -height/2, width, height);
            ctx.strokeRect(-width/2, -height/2, width, height);

            // 라벨
            ctx.fillStyle = '#fff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(productData.name.substring(0, 10), 0, 3);

            ctx.restore();

            // 안전 여유공간 표시
            if (selectedFloorPlanItem === product) {
                drawSafetyMargins(ctx, product, productData, scale, offsetX, offsetY);
            }
        }

        // 안전 여유공간 그리기
        function drawSafetyMargins(ctx, product, productData, scale, offsetX, offsetY) {
            ctx.strokeStyle = '#FF5722';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);

            const margins = productData.safetyMargins;
            const x = offsetX + (product.x - margins.side) * scale;
            const y = offsetY + (product.y - margins.front) * scale;
            const width = (productData.dimensions.width + margins.side * 2) * scale;
            const height = (productData.dimensions.length + margins.front + margins.back) * scale;

            ctx.strokeRect(x, y, width, height);
            ctx.setLineDash([]);
        }

        // 축척 정보 업데이트
        function updateScaleDisplay(scale) {
            const scaleRatio = Math.round(1 / scale);
            document.getElementById('scaleDisplay').textContent = `1:${scaleRatio}`;
            document.getElementById('gridDisplay').textContent = `${systemData.floorPlan.gridSize}mm`;
        }

        // 마우스 이벤트 핸들러
        function onFloorPlanMouseDown(e) {
            const rect = floorPlanCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 클릭된 객체 찾기
            const clickResult = findFloorPlanItemAt(x, y);
            if (clickResult) {
                selectedFloorPlanItem = clickResult;
                isDragging = true;
                dragOffset.x = x - (20 + clickResult.item.x * systemData.floorPlan.scale);
                dragOffset.y = y - (20 + clickResult.item.y * systemData.floorPlan.scale);

                // 커서 변경
                floorPlanCanvas.style.cursor = 'grabbing';
            } else {
                selectedFloorPlanItem = null;
                floorPlanCanvas.style.cursor = 'crosshair';
            }

            updateFloorPlan();
            updateCoordinateDisplay(e);
        }

        function onFloorPlanMouseMove(e) {
            if (!isDragging || !selectedFloorPlanItem) {
                // 드래그 중이 아닐 때는 호버 효과
                const clickResult = findFloorPlanItemAt(e.clientX - floorPlanCanvas.getBoundingClientRect().left,
                                                       e.clientY - floorPlanCanvas.getBoundingClientRect().top);
                floorPlanCanvas.style.cursor = clickResult ? 'grab' : 'crosshair';
                updateCoordinateDisplay(e);
                return;
            }

            const rect = floorPlanCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 격자에 스냅된 좌표 계산
            const rawX = (x - dragOffset.x - 20) / systemData.floorPlan.scale;
            const rawY = (y - dragOffset.y - 20) / systemData.floorPlan.scale;

            // Shift 키를 누르면 격자 스냅 비활성화
            const enableSnap = !e.shiftKey;

            if (enableSnap) {
                selectedFloorPlanItem.item.x = snapToGrid(rawX);
                selectedFloorPlanItem.item.y = snapToGrid(rawY);
            } else {
                selectedFloorPlanItem.item.x = rawX;
                selectedFloorPlanItem.item.y = rawY;
            }

            // 경계 검사 및 제한
            constrainToBounds(selectedFloorPlanItem);

            updateFloorPlan();
            updateCoordinateDisplay(e);

            // 리스트 업데이트
            if (selectedFloorPlanItem.type === 'reactor') {
                updateReactorProductsList();
            } else if (selectedFloorPlanItem.type === 'equipment') {
                updateExistingEquipmentList();
            } else if (selectedFloorPlanItem.type === 'door') {
                updateDoorsList();
            }
        }

        function onFloorPlanMouseUp(e) {
            isDragging = false;
            floorPlanCanvas.style.cursor = 'crosshair';

            // 좌표 표시 숨기기
            hideCoordinateDisplay();
        }

        // 터치 이벤트 핸들러들 (모바일 지원)
        function onFloorPlanTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = floorPlanCanvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // 클릭된 객체 찾기
                const clickResult = findFloorPlanItemAt(x, y);
                if (clickResult) {
                    selectedFloorPlanItem = clickResult;
                    isDragging = true;
                    dragOffset.x = x - (20 + clickResult.item.x * systemData.floorPlan.scale);
                    dragOffset.y = y - (20 + clickResult.item.y * systemData.floorPlan.scale);
                } else {
                    selectedFloorPlanItem = null;
                }

                updateFloorPlan();
            }
        }

        function onFloorPlanTouchMove(e) {
            if (!isDragging || !selectedFloorPlanItem || e.touches.length !== 1) {
                return;
            }

            const touch = e.touches[0];
            const rect = floorPlanCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // 격자에 스냅된 좌표 계산
            const rawX = (x - dragOffset.x - 20) / systemData.floorPlan.scale;
            const rawY = (y - dragOffset.y - 20) / systemData.floorPlan.scale;

            // 터치에서는 기본적으로 격자 스냅 활성화
            selectedFloorPlanItem.item.x = snapToGrid(rawX);
            selectedFloorPlanItem.item.y = snapToGrid(rawY);

            // 경계 검사 및 제한
            constrainToBounds(selectedFloorPlanItem);

            updateFloorPlan();

            // 리스트 업데이트
            if (selectedFloorPlanItem.type === 'reactor') {
                updateReactorProductsList();
            } else if (selectedFloorPlanItem.type === 'equipment') {
                updateExistingEquipmentList();
            } else if (selectedFloorPlanItem.type === 'door') {
                updateDoorsList();
            }
        }

        function onFloorPlanTouchEnd(e) {
            isDragging = false;
        }

        // 경계 제한 함수
        function constrainToBounds(selectedItem) {
            const room = systemData.floorPlan.roomDimensions;
            const item = selectedItem.item;

            let width, height;

            if (selectedItem.type === 'reactor') {
                const productData = reactorProductDB[item.productId];
                if (!productData) return;
                width = productData.dimensions.width;
                height = productData.dimensions.length;

                // 일반 객체는 방 안쪽으로 제한
                item.x = Math.max(0, Math.min(item.x, room.width - width));
                item.y = Math.max(0, Math.min(item.y, room.length - height));

            } else if (selectedItem.type === 'equipment') {
                width = item.width;
                height = item.length;

                // 일반 객체는 방 안쪽으로 제한
                item.x = Math.max(0, Math.min(item.x, room.width - width));
                item.y = Math.max(0, Math.min(item.y, room.length - height));

            } else if (selectedItem.type === 'door') {
                // 출입구는 외곽 경계에만 배치 가능
                constrainDoorToBounds(item, room);
            }
        }

        // 출입구 외곽 경계 제한 함수 (방향 자동 변경 포함)
        function constrainDoorToBounds(door, room) {
            const doorWidth = door.width;

            // 현재 위치에서 가장 가까운 벽 찾기
            const distToTop = Math.abs(door.y - 0);
            const distToBottom = Math.abs(door.y - room.length);
            const distToLeft = Math.abs(door.x - 0);
            const distToRight = Math.abs(door.x - room.width);

            const minDist = Math.min(distToTop, distToBottom, distToLeft, distToRight);

            // 가장 가까운 벽에 따라 방향과 위치 결정
            if (minDist === distToTop || minDist === distToBottom) {
                // 상단 또는 하단 벽 → 가로형으로 변경
                door.orientation = 'horizontal';

                // X 좌표 제한 (방 폭 내에서)
                door.x = Math.max(0, Math.min(door.x, room.width - doorWidth));

                // Y 좌표를 가까운 벽으로 스냅
                if (minDist === distToTop) {
                    door.y = 0; // 상단 벽
                } else {
                    door.y = room.length; // 하단 벽
                }

            } else {
                // 좌측 또는 우측 벽 → 세로형으로 변경
                door.orientation = 'vertical';

                // Y 좌표 제한 (방 길이 내에서)
                door.y = Math.max(0, Math.min(door.y, room.length - doorWidth));

                // X 좌표를 가까운 벽으로 스냅
                if (minDist === distToLeft) {
                    door.x = 0; // 좌측 벽
                } else {
                    door.x = room.width; // 우측 벽
                }
            }
        }

        // 실시간 좌표 표시
        function updateCoordinateDisplay(e) {
            const rect = floorPlanCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 실제 mm 좌표 계산
            const realX = (x - 20) / systemData.floorPlan.scale;
            const realY = (y - 20) / systemData.floorPlan.scale;

            // 좌표 표시 요소 생성 또는 업데이트
            let coordDisplay = document.getElementById('coordinateDisplay');
            if (!coordDisplay) {
                coordDisplay = document.createElement('div');
                coordDisplay.id = 'coordinateDisplay';
                coordDisplay.style.cssText = `
                    position: absolute;
                    background: rgba(0,0,0,0.8);
                    color: white;
                    padding: 5px 10px;
                    border-radius: 3px;
                    font-size: 12px;
                    pointer-events: none;
                    z-index: 1000;
                    white-space: nowrap;
                `;
                document.body.appendChild(coordDisplay);
            }

            coordDisplay.style.left = (e.clientX + 10) + 'px';
            coordDisplay.style.top = (e.clientY - 30) + 'px';
            coordDisplay.textContent = `X: ${Math.round(realX)}mm, Y: ${Math.round(realY)}mm`;
            coordDisplay.style.display = 'block';
        }

        function hideCoordinateDisplay() {
            const coordDisplay = document.getElementById('coordinateDisplay');
            if (coordDisplay) {
                coordDisplay.style.display = 'none';
            }
        }

        function onFloorPlanWheel(e) {
            e.preventDefault();

            // 줌 인/아웃 기능
            const delta = e.deltaY > 0 ? 0.9 : 1.1;  // 휠 다운: 축소, 휠 업: 확대
            systemData.floorPlan.scale *= delta;

            // 최소/최대 배율 제한
            const minScale = 0.01;  // 0.1 → 0.01로 변경 (더 많이 축소 가능)
            const maxScale = 3;
            systemData.floorPlan.scale = Math.max(minScale, Math.min(maxScale, systemData.floorPlan.scale));

            updateFloorPlan();
        }

        // 격자에 스냅하는 함수 (100mm 단위)
        function snapToGrid(value) {
            const gridSize = systemData.floorPlan.gridSize; // 100mm
            return Math.round(value / gridSize) * gridSize;
        }

        // 클릭 위치의 객체 찾기
        function findFloorPlanItemAt(canvasX, canvasY) {
            const scale = systemData.floorPlan.scale;
            const offsetX = 50;
            const offsetY = 30;

            // 리액터 제품 검사
            for (let product of systemData.floorPlan.reactorProducts) {
                const productData = reactorProductDB[product.productId];
                if (!productData) continue;

                const x = offsetX + product.x * scale;
                const y = offsetY + product.y * scale;
                const width = productData.dimensions.width * scale;
                const height = productData.dimensions.length * scale;

                if (canvasX >= x && canvasX <= x + width && canvasY >= y && canvasY <= y + height) {
                    return { type: 'reactor', item: product };
                }
            }

            // 기존 설비 검사
            for (let equipment of systemData.floorPlan.existingEquipment) {
                const x = offsetX + equipment.x * scale;
                const y = offsetY + equipment.y * scale;
                const width = equipment.width * scale;
                const height = equipment.length * scale;

                if (canvasX >= x && canvasX <= x + width && canvasY >= y && canvasY <= y + height) {
                    return { type: 'equipment', item: equipment };
                }
            }

            // 출입구 검사 (더 넓은 감지 영역)
            for (let door of systemData.floorPlan.doors) {
                const x = offsetX + door.x * scale;
                const y = offsetY + door.y * scale;
                let width, height;
                const thickness = 12; // 12픽셀 두께와 동일

                if (door.orientation === 'horizontal') {
                    width = door.width * scale;
                    height = thickness;
                    // 감지 영역 중앙 정렬
                    const detectionY = y - thickness/2;
                    if (canvasX >= x && canvasX <= x + width && canvasY >= detectionY && canvasY <= detectionY + height) {
                        return { type: 'door', item: door };
                    }
                } else {
                    width = thickness;
                    height = door.width * scale;
                    // 감지 영역 중앙 정렬
                    const detectionX = x - thickness/2;
                    if (canvasX >= detectionX && canvasX <= detectionX + width && canvasY >= y && canvasY <= y + height) {
                        return { type: 'door', item: door };
                    }
                }
            }

            return null;
        }

        // 출입구 추가
        function addDoor() {
            const door = {
                x: 0,
                y: 0,
                width: 900,
                orientation: 'horizontal'
            };

            systemData.floorPlan.doors.push(door);
            updateDoorsList();
            updateFloorPlan();
        }

        // 출입구 목록 업데이트
        function updateDoorsList() {
            const container = document.getElementById('doorsList');
            container.innerHTML = '';

            systemData.floorPlan.doors.forEach((door, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'margin: 5px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: #f9f9f9;';
                div.innerHTML = `
                    <div style="margin-bottom: 8px; font-weight: bold;">출입구 ${index + 1}</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 8px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">X(mm):</label>
                            <input type="number" placeholder="X좌표" value="${door.x}"
                                   onchange="systemData.floorPlan.doors[${index}].x = parseInt(this.value) || 0; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">Y(mm):</label>
                            <input type="number" placeholder="Y좌표" value="${door.y}"
                                   onchange="systemData.floorPlan.doors[${index}].y = parseInt(this.value) || 0; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                        </div>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">폭(mm):</label>
                        <input type="number" placeholder="문폭" value="${door.width}"
                               onchange="systemData.floorPlan.doors[${index}].width = parseInt(this.value) || 900; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                    </div>
                    <div style="margin-bottom: 8px; padding: 5px; background: #e8f5e8; border-radius: 3px; font-size: 12px; color: #2e7d32;">
                        현재 방향: <strong>${door.orientation === 'horizontal' ? '가로형' : '세로형'}</strong> (자동 설정)
                    </div>
                    <button onclick="removeDoor(${index})" style="background: #f44336; color: white; border: none; padding: 2px 6px; border-radius: 3px;">삭제</button>
                `;
                container.appendChild(div);
            });
        }

        // 출입구 삭제
        function removeDoor(index) {
            systemData.floorPlan.doors.splice(index, 1);
            updateDoorsList();
            updateFloorPlan();
        }

        // 기존 설비 추가
        function addExistingEquipment() {
            const equipment = {
                id: 'eq' + Date.now(),
                x: 1000,
                y: 1000,
                width: 800,
                length: 600,
                name: '기존설비'
            };

            systemData.floorPlan.existingEquipment.push(equipment);
            updateExistingEquipmentList();
            updateFloorPlan();
        }

        // 기존 설비 목록 업데이트
        function updateExistingEquipmentList() {
            const container = document.getElementById('existingEquipmentList');
            container.innerHTML = '';

            systemData.floorPlan.existingEquipment.forEach((equipment, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'margin: 5px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: #f9f9f9;';
                div.innerHTML = `
                    <div style="margin-bottom: 8px;">
                        <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">설비명:</label>
                        <input type="text" placeholder="설비명" value="${equipment.name}"
                               onchange="systemData.floorPlan.existingEquipment[${index}].name = this.value; updateFloorPlan()" style="width: 100%;">
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 8px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">X(mm):</label>
                            <input type="number" placeholder="X좌표" value="${equipment.x}"
                                   onchange="systemData.floorPlan.existingEquipment[${index}].x = parseInt(this.value) || 0; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">Y(mm):</label>
                            <input type="number" placeholder="Y좌표" value="${equipment.y}"
                                   onchange="systemData.floorPlan.existingEquipment[${index}].y = parseInt(this.value) || 0; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 8px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">폭(mm):</label>
                            <input type="number" placeholder="폭" value="${equipment.width}"
                                   onchange="systemData.floorPlan.existingEquipment[${index}].width = parseInt(this.value) || 800; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">깊이(mm):</label>
                            <input type="number" placeholder="깊이" value="${equipment.length}"
                                   onchange="systemData.floorPlan.existingEquipment[${index}].length = parseInt(this.value) || 600; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                        </div>
                    </div>
                    <button onclick="removeExistingEquipment(${index})" style="background: #f44336; color: white; border: none; padding: 2px 6px; border-radius: 3px;">삭제</button>
                `;
                container.appendChild(div);
            });
        }

        // 기존 설비 삭제
        function removeExistingEquipment(index) {
            systemData.floorPlan.existingEquipment.splice(index, 1);
            updateExistingEquipmentList();
            updateFloorPlan();
        }

        // 리액터 제품 추가
        function addReactorProduct() {
            const productId = document.getElementById('reactorProductSelect').value;
            if (!productId) {
                alert('제품을 선택해주세요.');
                return;
            }

            const product = {
                id: 'rp' + Date.now(),
                x: 2000,
                y: 2000,
                productId: productId,
                rotation: 0
            };

            systemData.floorPlan.reactorProducts.push(product);
            updateReactorProductsList();
            updateFloorPlan();

            // 자동 배치 실행
            autoPositionReactorProducts();
        }

        // 리액터 제품 목록 업데이트
        function updateReactorProductsList() {
            const container = document.getElementById('reactorProductsList');
            container.innerHTML = '';

            systemData.floorPlan.reactorProducts.forEach((product, index) => {
                const productData = reactorProductDB[product.productId];
                const div = document.createElement('div');
                div.style.cssText = 'margin: 5px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: #f9f9f9;';
                div.innerHTML = `
                    <div style="margin-bottom: 8px;"><strong>${productData.name}</strong></div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 8px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">X(mm):</label>
                            <input type="number" placeholder="X좌표" value="${product.x}"
                                   onchange="systemData.floorPlan.reactorProducts[${index}].x = parseInt(this.value) || 0; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">Y(mm):</label>
                            <input type="number" placeholder="Y좌표" value="${product.y}"
                                   onchange="systemData.floorPlan.reactorProducts[${index}].y = parseInt(this.value) || 0; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                        </div>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="display: block; font-size: 12px; color: #666; margin-bottom: 2px;">각도(°):</label>
                        <input type="number" placeholder="0-360도" value="${product.rotation}"
                               onchange="systemData.floorPlan.reactorProducts[${index}].rotation = parseInt(this.value) || 0; updateFloorPlan()" style="width: 100%;" inputmode="numeric" pattern="[0-9]*">
                    </div>
                    <button onclick="removeReactorProduct(${index})" style="background: #f44336; color: white; border: none; padding: 2px 6px; border-radius: 3px;">삭제</button>
                `;
                container.appendChild(div);
            });
        }

        // 리액터 제품 삭제
        function removeReactorProduct(index) {
            systemData.floorPlan.reactorProducts.splice(index, 1);
            updateReactorProductsList();
            updateFloorPlan();
        }

        // 자동 배치 알고리즘
        function autoPositionReactorProducts() {
            const room = systemData.floorPlan.roomDimensions;
            const products = systemData.floorPlan.reactorProducts;

            if (products.length === 0) return;

            // 간단한 격자 배치 알고리즘
            const gridCols = Math.ceil(Math.sqrt(products.length));
            const gridRows = Math.ceil(products.length / gridCols);

            products.forEach((product, index) => {
                const productData = reactorProductDB[product.productId];
                if (!productData) return;

                const col = index % gridCols;
                const row = Math.floor(index / gridCols);

                const cellWidth = room.width / gridCols;
                const cellHeight = room.length / gridRows;

                const margins = productData.safetyMargins;

                product.x = col * cellWidth + margins.side;
                product.y = row * cellHeight + margins.front;

                // 경계 체크
                const maxX = room.width - productData.dimensions.width - margins.side;
                const maxY = room.length - productData.dimensions.length - margins.back;

                product.x = Math.min(product.x, maxX);
                product.y = Math.min(product.y, maxY);
            });

            updateReactorProductsList();
            updateFloorPlan();
        }

        // 평면도 축척 리셋
        function resetFloorPlanZoom() {
            systemData.floorPlan.scale = 0;  // 0으로 설정하면 updateFloorPlan에서 자동 계산
            updateFloorPlan();
        }

        // 평면도 초기화
        function resetFloorPlan() {
            if (confirm('평면도 데이터를 모두 초기화하시겠습니까?')) {
                systemData.floorPlan = {
                    enabled: false,
                    roomDimensions: { width: 0, length: 0, height: 0 },
                    doors: [],
                    existingEquipment: [],
                    reactorProducts: [],
                    scale: 1,
                    gridSize: 100,
                    safetyMargins: { front: 800, back: 600, side: 400 }
                };

                loadFloorPlanData();
                updateFloorPlan();
            }
        }

        // 평면도 저장
        function saveFloorPlan() {
            systemData.floorPlan.enabled = true;
            closeFloorPlan();
            alert('✅ 평면도가 저장되었습니다!');
        }

        // 평면도 PDF 출력
        function exportFloorPlan() {
            // 간단한 구현: 캔버스를 이미지로 변환하여 새 창에서 출력
            const canvas = floorPlanCanvas;
            const dataURL = canvas.toDataURL('image/png');

            const newWindow = window.open('', '_blank');
            newWindow.document.write(`
                <html>
                <head><title>평면도 출력</title></head>
                <body style="margin: 0; text-align: center;">
                    <h2>설치 위치 평면도</h2>
                    <img src="${dataURL}" style="max-width: 100%; height: auto;">
                    <br><br>
                    <button onclick="window.print()">인쇄</button>
                    <button onclick="window.close()">닫기</button>
                </body>
                </html>
            `);
        }
    </script>
</body>
</html>
